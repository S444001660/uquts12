شاشة إضافة وتعديل جهاز (AddDeviceScreen)

📝 نظرة عامة
هذه الشاشة هي جزء محوري في التطبيق، حيث تتيح للمستخدمين إضافة جهاز جديد إلى معمل معين أو تعديل بيانات جهاز موجود بالفعل. تدعم الشاشة عدة سيناريوهات بما في ذلك الإضافة اليدوية، الإضافة عن طريق مسح الباركود، التعديل، والحذف.

🌊 تدفق البيانات (Data Flow)
تدفق البيانات في هذه الشاشة يتبع دورة حياة واضحة من التحميل الأولي إلى الحفظ.

1. التحميل الأولي (Initial Load)
   الزناد: عند فتح الشاشة، يتم استدعاء initState التي بدورها تستدعي \_loadInitialData.

الإجراء:

* يتم عرض مؤشر تحميل (\_isLoading = true).
* يتم جلب قائمة جميع المعامل المتاحة من Firebase وتخزينها في \_availableLabs.
* بناءً على السياق، يتم أحد الإجراءات التالية:

  * في حالة التعديل (widget.device موجود): تُستدعى \_loadDeviceData لتعبئة حقول الواجهة ببيانات الجهاز الحالية.
  * في حالة مسح باركود (widget.scannedBarcodeData موجود): تُستدعى \_loadScannedBarcodeData لملء الحقول المتعلقة ببيانات الأصل (الرقم التسلسلي، رمز الأصل، إلخ).
  * في حالة فتح الشاشة من معمل معين (widget.labId موجود): تُستدعى \_loadLabDetails لجلب تفاصيل المعمل وتحديده مسبقًا في القائمة المنسدلة.

النتيجة: تختفي دائرة التحميل، وتكون الشاشة جاهزة للاستخدام مع قائمة معامل مُعبأة، وقد تكون حقول الجهاز مملوءة مسبقًا.

2. تفاعل المستخدم (User Interaction)

* إدخال البيانات: يقوم المستخدم بملء حقول النص، ويتم تخزين القيم في وحدات التحكم (TextEditingController).
* الاختيار من القوائم: عند اختيار معمل، موديل، أو معالج، يتم تحديث متغيرات الحالة وقيم وحدات التحكم.
* تحديد الخيارات: عند تفعيل/إلغاء خيارات مثل "يحتاج إلى صيانة" (\_needsMaintenance) أو "تخزين إضافي" (\_hasExtraStorage)، يتم تحديث متغيرات الحالة المنطقية (bool) عبر setState.
* التقاط صورة: عند الضغط على زر الكاميرا، تستدعي \_pickImage التي تفتح الكاميرا، وتُخزّن الصورة الملتقطة في المتغير \_capturedImage.

3. عملية الحفظ (Save Process)
   الزناد: يضغط المستخدم على زر "حفظ" أو "حفظ ومتابعة"، مما يؤدي إلى استدعاء \_saveAndPop أو \_saveAndAddAnother على التوالي.

الإجراء المركزي: كلتا الدالتين تستدعيان الدالة المحورية \_performSave التي تقوم بالآتي:

* التحقق (\_validateInputs): تتحقق من صحة جميع الحقول، ومن تطبيق الشروط (مثل وجود صورة للصيانة)، ومن عدم تكرار الرقم التسلسلي. إذا فشل أي شرط، يتم إطلاق خطأ throw Exception ويتم إيقاف العملية.
* رفع الصورة (\_handleImageUpload): إذا التقط المستخدم صورة جديدة، يتم رفعها إلى Firebase Storage. إذا لم تكن هناك حاجة للصورة، يتم تحديد قيمتها كـ null. تُرجع الدالة رابط الصورة النهائي.
* بناء الكائن: يتم تجميع كل البيانات من حقول الإدخال ومتغيرات الحالة في كائن واحد منظم من نوع DeviceModel.
* الحفظ في قاعدة البيانات: يتم إرسال الكائن DeviceModel إلى FirebaseDatabaseService لحفظه.

النتيجة: يتم إنشاء سجل جديد أو تحديث سجل حالي في Firebase. تُرجع \_performSave الكائن المحفوظ عند النجاح أو null عند الفشل.

4. ما بعد الحفظ (Post-Save)

* عند "حفظ وخروج": تُعرض رسالة نجاح، ثم يتم إغلاق الشاشة (Navigator.pop).
* عند "حفظ ومتابعة": تُعرض رسالة نجاح، ثم تُستدعى \_resetFormForNextDevice لتفريغ الحقول، مما يسمح للمستخدم بإضافة جهاز آخر بسرعة في نفس المعمل.

🎭 سيناريوهات الاستخدام (Usage Scenarios)

1. إضافة جهاز جديد
   الوصف: يقوم المستخدم بفتح الشاشة من صفحة معمل معين لإضافة جهاز جديد.
   الخطوات:

* يتم تحديد المعمل تلقائيًا.
* يملأ المستخدم جميع تفاصيل الجهاز (الاسم، الموديل، المواصفات، إلخ).
* يضغط على "إضافة الجهاز" أو "إضافة ومتابعة".
  النتيجة: يتم إنشاء جهاز جديد في قاعدة البيانات مرتبط بالمعمل المحدد.

2. تعديل جهاز موجود
   الوصف: يختار المستخدم جهازًا من قائمة لعرض تفاصيله وتعديلها.
   الخطوات:

* تُفتح الشاشة وتُملأ جميع الحقول تلقائيًا ببيانات الجهاز الحالية عبر \_loadDeviceData.
* يُعدّل المستخدم البيانات المطلوبة (مثلاً: يضيف ملاحظات أو يغير حالة الصيانة ويلتقط صورة).
* يضغط على "حفظ التغييرات".
  النتيجة: يتم تحديث بيانات الجهاز في قاعدة البيانات.

3. إضافة جهاز عبر مسح الباركود
   الوصف: يقوم المستخدم بمسح باركود أصل جامعي، فيتم فتح شاشة الإضافة مع ملء البيانات المتاحة.
   الخطوات:

* تُفتح الشاشة وتُملأ حقول "الرقم التسلسلي"، "رمز الأصل" وغيرها من البيانات المستخرجة من الباركود عبر \_loadScannedBarcodeData.
* يكمل المستخدم باقي البيانات (مثل اسم الجهاز والموديل).
* يحفظ الجهاز.
  النتيجة: يتم إنشاء جهاز جديد مع ربطه بمعلومات الأصل الجامعي الصحيحة.

4. حذف جهاز
   الوصف: هذا السيناريو متاح فقط في وضع التعديل.
   الخطوات:

* يضغط المستخدم على أيقونة الحذف في شريط العنوان.
* يظهر مربع حوار للتأكيد.
* عند التأكيد، تُستدعى \_deleteDevice.
  النتيجة: يتم حذف سجل الجهاز من قاعدة البيانات نهائيًا.

⚙️ الدوال الرئيسية ووظائفها

* \_loadInitialData: نقطة البداية لجلب كل البيانات اللازمة عند فتح الشاشة.
* \_loadDeviceData: مسؤولة عن تعبئة الواجهة ببيانات جهاز موجود (وضع التعديل).
* \_loadScannedBarcodeData: مسؤولة عن تعبئة الواجهة ببيانات من باركود ممسوح.
* \_performSave: الدالة المنسقة التي تدير عملية الحفظ بأكملها.
* \_validateInputs: تتحقق من صحة جميع المدخلات والشروط قبل محاولة الحفظ.
* \_handleImageUpload: تدير منطق رفع الصور إلى Firebase Storage.
* \_saveAndPop / \_saveAndAddAnother: الأزرار النهائية التي يراها المستخدم، وكل منها له سلوك مختلف بعد الحفظ.
* \_resetFormForNextDevice: تقوم بتنظيف الفورم للسماح بإدخال جهاز جديد.
* \_deleteDevice: تدير عملية الحذف مع طلب تأكيد من المستخدم.
* build: الدالة الأساسية المسؤولة عن بناء ورسم كل عناصر واجهة المستخدم على الشاشة.
----------------------------------------------------------------------------------------------------------------------------
شاشة إضافة وتعديل معمل (AddLabScreen)

📝 نظرة عامة
هذه الشاشة مسؤولة عن إدارة بيانات المعامل، وتتيح للمستخدمين إنشاء معامل جديدة أو تعديل بيانات معامل قائمة. تم إعادة هيكلة هذه الشاشة بشكل كبير لفصل المنطق عن واجهة المستخدم، مما يجعل الكود أكثر نظافة وقابلية للصيانة والأداء. تم تفكيك عناصر الواجهة المتكررة إلى ويدجتات صغيرة ومستقلة (Stateless Widgets).

🌊 تدفق البيانات (Data Flow)
يتبع تدفق البيانات في هذه الشاشة مساراً منطقياً بدءاً من تحميل البيانات وانتهاءً بحفظها.

1. التحميل الأولي (Initial Load)
   الزناد: عند فتح الشاشة، تستدعي دالة initState.

الإجراء:

* يتم تهيئة وحدات التحكم (TextEditingController) الخاصة برقم المعمل والملاحظات.
* إذا كانت الشاشة في وضع التعديل (أي widget.lab يحتوي على بيانات)، تُستدعى دالة \_loadExistingLabData.
* تقوم \_loadExistingLabData بتعبئة متغيرات الحالة (\_selectedCollege, \_labStatus, \_existingImageUrl, إلخ) بالبيانات القادمة من المعمل الموجود.

النتيجة: يتم عرض الفورم للمستخدم، إما فارغاً في حالة "الإضافة"، أو مملوءاً ببيانات المعمل الحالية في حالة "التعديل".

2. تفاعل المستخدم (User Interaction)

* اختيار من القوائم: عند اختيار المستخدم لقيمة من أي قائمة منسدلة (مثل \_CollegeDropdown أو \_LabStatusDropdown)، يتم تفعيل دالة onChanged الخاصة بها. تقوم هذه الدالة بتحديث متغير الحالة المناسب باستخدام setState، مما يؤدي إلى إعادة بناء الواجهة لعرض التغيير.

منطق مرتبط بالحالات:

* عند تغيير الكلية، يتم إعادة تعيين القسم إلى null لإجبار المستخدم على اختيار قسم جديد متوافق مع الكلية الجديدة.
* عند تغيير حالة المعمل إلى openWithDevices (مفتوح مع أجهزة)، يتم حذف أي صورة حالية (\_capturedImage أو \_existingImageUrl) لأنها غير مطلوبة في هذه الحالة.
* التقاط صورة: عند الضغط على زر الكاميرا، تُستدعى دالة \_pickImage التي تستخدم ImageUtils لفتح الكاميرا، وتتحقق من حجم الصورة، ثم تحدث متغير الحالة \_capturedImage.

3. عملية الحفظ (Save Process)
   الزناد: يضغط المستخدم على أحد أزرار الحفظ، مما يستدعي \_saveLabAndPop أو \_saveLabAndAddDevice.

الإجراء المركزي: كلتا الدالتين تستدعيان الدالة المحورية \_performSave التي تنفذ الخطوات التالية:

* التحقق: يتم التحقق من صحة جميع حقول الفورم.
* التحقق من شرط الصورة: يتم التأكد من وجود صورة إذا كانت حالة المعمل تتطلب ذلك (مغلق أو به مشكلة).
* عرض التحميل: يتم تفعيل \_isLoading لعرض مؤشر تحميل.
* معالجة الصورة: يتم تحديد رابط الصورة النهائي. إذا التقط المستخدم صورة جديدة، يتم رفعها. إذا كانت هناك صورة قديمة ولا تزال مطلوبة، يتم الاحتفاظ بها.
* بناء الكائن: يتم تجميع كل البيانات المحدثة من وحدات التحكم ومتغيرات الحالة في كائن واحد من نوع LabModel.
* الحفظ: يُرسل الكائن إلى FirebaseDatabaseService لحفظه في قاعدة البيانات.

النتيجة: يتم إنشاء أو تحديث سجل المعمل في Firebase.

4. ما بعد الحفظ (Post-Save)

* عند "حفظ التغييرات" أو "إضافة المعمل": بعد نجاح الحفظ، تُعرض رسالة نجاح ويتم إغلاق الشاشة (Navigator.pop).
* عند "إضافة معمل مع الجهاز": بعد نجاح الحفظ، تُعرض رسالة نجاح ويتم استبدال الشاشة الحالية بشاشة AddDeviceScreen (Navigator.pushReplacement)، مع تمرير id المعمل الجديد لربط الجهاز به مباشرة.

🎭 سيناريوهات الاستخدام (Usage Scenarios)

1. إضافة معمل جديد فقط
   الوصف: يقوم المستخدم بإنشاء سجل لمعمل جديد في النظام.
   الخطوات: يملأ المستخدم بيانات المعمل (الرقم، الكلية، الدور، إلخ)، ثم يضغط على زر "إضافة المعمل".
   النتيجة: يتم حفظ المعمل ويعود المستخدم إلى الشاشة السابقة.

2. إضافة معمل ثم إضافة جهاز له مباشرة
   الوصف: يقوم المستخدم بإنشاء معمل جديد ويريد إضافة أول جهاز له فوراً.
   الخطوات: يملأ المستخدم بيانات المعمل، ثم يضغط على زر "إضافة معمل مع الجهاز".
   النتيجة: يتم حفظ المعمل، ثم ينتقل المستخدم تلقائياً إلى شاشة إضافة جهاز، حيث يكون المعمل الجديد محدداً مسبقاً.

3. تعديل بيانات معمل موجود
   الوصف: يقوم المستخدم بتحديث معلومات معمل مسجل مسبقاً.
   الخطوات:

* تُفتح الشاشة وتكون مملوءة ببيانات المعمل الحالية.
* يقوم المستخدم بتغيير البيانات (مثلاً، يغير الحالة من "مفتوح" إلى "مغلق" ويلتقط صورة للتوثيق).
* يضغط على "حفظ التغييرات".
  النتيجة: يتم تحديث سجل المعمل في قاعدة البيانات.

4. إضافة جهاز إلى معمل موجود بالفعل
   الوصف: أثناء تعديل بيانات معمل، يقرر المستخدم إضافة جهاز جديد إلى هذا المعمل.
   الخطوات: في شاشة تعديل المعمل، يضغط المستخدم على زر "إضافة جهاز".
   النتيجة: ينتقل المستخدم إلى شاشة إضافة جهاز، ويكون المعمل الحالي محدداً مسبقاً.

⚙️ المكونات والويدجتات الرئيسية
تم تصميم هذه الشاشة عبر فصل المكونات إلى ويدجتات صغيرة قابلة لإعادة الاستخدام:

* \_AddLabScreenState: الكلاس الرئيسي الذي يدير كل متغيرات الحالة والمنطق الخاص بالشاشة.
* \_CustomTextField: ويدجت موحد لحقول الإدخال النصية.
* \_LabStatusDropdown, \_CollegeDropdown, \_DepartmentDropdown, إلخ: كل قائمة منسدلة تم فصلها في ويدجت خاص بها، مما يجعل كود البناء الرئيسي نظيفاً وسهل القراءة.
* \_ImageCaptureSection: ويدجت يجمع كل ما يتعلق بعرض الصورة الملتقطة أو الموجودة وزر التقاط الصورة.
* \_ActionButtons: ويدجت ذكي يعرض الأزرار المناسبة بناءً على سياق الشاشة (هل هي للإضافة أم للتعديل؟)، مما يقلل من الشروط المنطقية في دالة build الرئيسية.
----------------------------------------------------------------------------------------------------------------------------
شاشة ماسح الباركود (BarcodeScannerScreen)

📝 نظرة عامة
تعمل هذه الشاشة كبوابة رئيسية لتسجيل ومتابعة الأجهزة عبر مسح الباركود. تستخدم كاميرا الجهاز لاكتشاف الباركود، ثم تتخذ قرارًا ذكيًا بناءً على ما إذا كان الجهاز مسجلاً في قاعدة البيانات أم لا. تم تصميم الشاشة للتحكم الدقيق في دورة حياة الماسح الضوئي لضمان تجربة مستخدم سلسة وموثوقة.

🌊 تدفق البيانات (Data Flow)
يتبع تدفق البيانات والتحكم في هذه الشاشة تسلسلاً منطقياً يضمن معالجة كل باركود بشكل صحيح.

1. التحميل والتهيئة (Loading and Initialization)
   الزناد: عند فتح الشاشة، يتم استدعاء دالة initState.

الإجراء:

* تُستدعى \_loadLabs() لجلب قائمة المعامل المتاحة من Firebase بشكل غير متزامن. يتم عرض مؤشر تحميل (\_isLoading) أثناء هذه العملية.
* في نفس الوقت، تُستدعى \_startScanner() لبدء تشغيل الكاميرا والماسح الضوئي بشكل صريح، حيث تم تعطيل التشغيل التلقائي (autoStart: false).

النتيجة: يرى المستخدم واجهة الكاميرا جاهزة للمسح فوراً، بينما يتم تحميل قائمة المعامل في الخلفية لاستخدامها لاحقاً إذا لزم الأمر.

2. اكتشاف الباركود ومعالجته (Barcode Detection & Handling)
   الزناد: عندما تكتشف الكاميرا باركوداً، يتم تفعيل onDetect الذي يستدعي بدوره الدالة المحورية \_handleBarcodeScan.

الإجراء داخل \_handleBarcodeScan:

* إيقاف الماسح: أول خطوة هي استدعاء \_stopScanner() لإيقاف الكاميرا ومنع اكتشاف نفس الباركود عدة مرات أثناء المعالجة.
* تحليل البيانات: يتم استخلاص بيانات الباركود الأول وتحليلها باستخدام BarcodeUtils.
* التحقق من قاعدة البيانات: تُستدعى \_checkDeviceExists() للبحث في Firebase عن جهاز يطابق بيانات الباركود.

النتيجة: يتفرع مسار عمل التطبيق بناءً على نتيجة البحث.

3. تفرع المسار (Path Bifurcation)

* إذا كان الجهاز موجوداً: تُستدعى دالة \_showExistingDeviceDialog.
* إذا كان الجهاز غير موجود: تُستدعى دالة \_navigateToNewDeviceRegistration.

4. معالجة النتائج وإعادة التشغيل (Result Handling & Scanner Restart)

* مسار الجهاز الموجود:

  * يظهر مربع حوار AlertDialog يعرض اسم الجهاز وزراً للانتقال إلى تفاصيله.
  * عند الضغط على الزر، ينتقل المستخدم إلى شاشة ViewDeviceScreen.
  * الأهم: عند إغلاق مربع الحوار أو العودة من شاشة التفاصيل، يتم استدعاء \_startScanner() من خلال .then() لإعادة تنشيط الكاميرا وتجهيزها لمسح جديد.

* مسار الجهاز الجديد:

  * ينتقل المستخدم مباشرة إلى شاشة AddDeviceScreen.
  * يتم تمرير بيانات الباركود (scannedBarcodeData) إلى الشاشة الجديدة لملء الحقول المتعلقة بالأصل تلقائياً.
  * الأهم: عند الانتهاء من إضافة الجهاز والعودة من شاشة AddDeviceScreen، يتم استدعاء \_startScanner() من خلال .then() لإعادة تنشيط الكاميرا.

🎭 سيناريوهات الاستخدام (Usage Scenarios)

1. مسح باركود لجهاز مسجل مسبقًا
   الوصف: يقوم المستخدم بمسح باركود جهاز موجود بالفعل في النظام للوصول إلى معلوماته بسرعة.
   الخطوات:

* يفتح المستخدم الماسح ويوجهه نحو الباركود.
* يكتشف التطبيق الباركود ويتحقق من قاعدة البيانات ويجد تطابقاً.
* يظهر مربع حوار يؤكد وجود الجهاز.
* يضغط المستخدم على "عرض تفاصيل الجهاز" للانتقال إلى شاشة العرض.
  النتيجة: وصول سريع لمعلومات الجهاز. عند العودة، يكون الماسح جاهزاً للعمل مرة أخرى.

2. مسح باركود لتسجيل جهاز جديد
   الوصف: يقوم المستخدم بمسح باركود جهاز غير مسجل في النظام بهدف إضافته.
   الخطوات:

* يوجه المستخدم الكاميرا نحو باركود جديد.
* يكتشف التطبيق الباركود ويبحث في قاعدة البيانات ولا يجد تطابقاً.
* يتم نقل المستخدم تلقائياً إلى شاشة AddDeviceScreen.
* تكون حقول مثل "الرقم التسلسلي" و"رمز الأصل" مملوءة مسبقاً.
* يكمل المستخدم باقي البيانات (اسم الجهاز، الموديل، ويختار المعمل) ثم يحفظ.
  النتيجة: عملية إضافة جهاز جديد سريعة ودقيقة، تقلل من أخطاء الإدخال اليدوي.

⚙️ التحكم بالماسح الضوئي (Scanner Control)
تم تصميم هذه الشاشة للتحكم اليدوي الكامل في الماسح الضوئي عبر:

* autoStart: false: لضمان عدم بدء تشغيل الكاميرا إلا عند الطلب.
* \_startScanner(): دالة مخصصة لبدء تشغيل الماسح.
* \_stopScanner(): دالة مخصصة لإيقاف الماسح.

هذا التحكم ضروري لمنع المشاكل الشائعة مثل معالجة نفس الباركود عدة مرات، ولضمان تحرير موارد الكاميرا عند إغلاق الشاشة أو الانتقال إلى شاشة أخرى، مما يحسن أداء التطبيق ويحافظ على البطارية.

🛠️ الدوال الرئيسية ووظائفها

* \_loadLabs: تجلب قائمة المعامل من Firebase لاستخدامها عند تسجيل جهاز جديد.
* \_startScanner / \_stopScanner: تدير دورة حياة الكاميرا بشكل دقيق.
* \_handleBarcodeScan: هي المنسق الرئيسي الذي يتم استدعاؤه عند اكتشاف باركود، وتقوم بتوجيه البيانات إلى المسار الصحيح.
* \_checkDeviceExists: تتواصل مع قاعدة البيانات للتحقق من وجود الجهاز.
* \_showExistingDeviceDialog: تدير واجهة المستخدم في حالة العثور على جهاز موجود.
* \_navigateToNewDeviceRegistration: تدير واجهة المستخدم في حالة عدم العثور على الجهاز.
* build: تبني واجهة المستخدم، وتعرض إما مؤشر تحميل أو واجهة الكاميرا مع أزرار التحكم بالفلاش والكاميرا.
----------------------------------------------------------------------------------------------------------------------------
شاشة ماسح الباركود (BarcodeScannerScreen)

📝 نظرة عامة
تعمل هذه الشاشة كبوابة رئيسية لتسجيل ومتابعة الأجهزة عبر مسح الباركود. تستخدم كاميرا الجهاز لاكتشاف الباركود، ثم تتخذ قرارًا ذكيًا بناءً على ما إذا كان الجهاز مسجلاً في قاعدة البيانات أم لا. تم تصميم الشاشة للتحكم الدقيق في دورة حياة الماسح الضوئي لضمان تجربة مستخدم سلسة وموثوقة.

🌊 تدفق البيانات (Data Flow)
يتبع تدفق البيانات والتحكم في هذه الشاشة تسلسلاً منطقياً يضمن معالجة كل باركود بشكل صحيح.

1. التحميل والتهيئة (Loading and Initialization)
   الزناد: عند فتح الشاشة، يتم استدعاء دالة initState.

الإجراء:

* تُستدعى \_loadLabs() لجلب قائمة المعامل المتاحة من Firebase بشكل غير متزامن. يتم عرض مؤشر تحميل (\_isLoading) أثناء هذه العملية.
* في نفس الوقت، تُستدعى \_startScanner() لبدء تشغيل الكاميرا والماسح الضوئي بشكل صريح، حيث تم تعطيل التشغيل التلقائي (autoStart: false).

النتيجة: يرى المستخدم واجهة الكاميرا جاهزة للمسح فوراً، بينما يتم تحميل قائمة المعامل في الخلفية لاستخدامها لاحقاً إذا لزم الأمر.

2. اكتشاف الباركود ومعالجته (Barcode Detection & Handling)
   الزناد: عندما تكتشف الكاميرا باركوداً، يتم تفعيل onDetect الذي يستدعي بدوره الدالة المحورية \_handleBarcodeScan.

الإجراء داخل \_handleBarcodeScan:

* إيقاف الماسح: أول خطوة هي استدعاء \_stopScanner() لإيقاف الكاميرا ومنع اكتشاف نفس الباركود عدة مرات أثناء المعالجة.
* تحليل البيانات: يتم استخلاص بيانات الباركود الأول وتحليلها باستخدام BarcodeUtils.
* التحقق من قاعدة البيانات: تُستدعى \_checkDeviceExists() للبحث في Firebase عن جهاز يطابق بيانات الباركود.

النتيجة: يتفرع مسار عمل التطبيق بناءً على نتيجة البحث.

3. تفرع المسار (Path Bifurcation)

* إذا كان الجهاز موجوداً: تُستدعى دالة \_showExistingDeviceDialog.
* إذا كان الجهاز غير موجود: تُستدعى دالة \_navigateToNewDeviceRegistration.

4. معالجة النتائج وإعادة التشغيل (Result Handling & Scanner Restart)

* مسار الجهاز الموجود:

  * يظهر مربع حوار AlertDialog يعرض اسم الجهاز وزراً للانتقال إلى تفاصيله.
  * عند الضغط على الزر، ينتقل المستخدم إلى شاشة ViewDeviceScreen.
  * الأهم: عند إغلاق مربع الحوار أو العودة من شاشة التفاصيل، يتم استدعاء \_startScanner() من خلال .then() لإعادة تنشيط الكاميرا وتجهيزها لمسح جديد.

* مسار الجهاز الجديد:

  * ينتقل المستخدم مباشرة إلى شاشة AddDeviceScreen.
  * يتم تمرير بيانات الباركود (scannedBarcodeData) إلى الشاشة الجديدة لملء الحقول المتعلقة بالأصل تلقائياً.
  * الأهم: عند الانتهاء من إضافة الجهاز والعودة من شاشة AddDeviceScreen، يتم استدعاء \_startScanner() من خلال .then() لإعادة تنشيط الكاميرا.

🎭 سيناريوهات الاستخدام (Usage Scenarios)

1. مسح باركود لجهاز مسجل مسبقًا
   الوصف: يقوم المستخدم بمسح باركود جهاز موجود بالفعل في النظام للوصول إلى معلوماته بسرعة.
   الخطوات:

* يفتح المستخدم الماسح ويوجهه نحو الباركود.
* يكتشف التطبيق الباركود ويتحقق من قاعدة البيانات ويجد تطابقاً.
* يظهر مربع حوار يؤكد وجود الجهاز.
* يضغط المستخدم على "عرض تفاصيل الجهاز" للانتقال إلى شاشة العرض.
  النتيجة: وصول سريع لمعلومات الجهاز. عند العودة، يكون الماسح جاهزاً للعمل مرة أخرى.

2. مسح باركود لتسجيل جهاز جديد
   الوصف: يقوم المستخدم بمسح باركود جهاز غير مسجل في النظام بهدف إضافته.
   الخطوات:

* يوجه المستخدم الكاميرا نحو باركود جديد.
* يكتشف التطبيق الباركود ويبحث في قاعدة البيانات ولا يجد تطابقاً.
* يتم نقل المستخدم تلقائياً إلى شاشة AddDeviceScreen.
* تكون حقول مثل "الرقم التسلسلي" و"رمز الأصل" مملوءة مسبقاً.
* يكمل المستخدم باقي البيانات (اسم الجهاز، الموديل، ويختار المعمل) ثم يحفظ.
  النتيجة: عملية إضافة جهاز جديد سريعة ودقيقة، تقلل من أخطاء الإدخال اليدوي.

⚙️ التحكم بالماسح الضوئي (Scanner Control)
تم تصميم هذه الشاشة للتحكم اليدوي الكامل في الماسح الضوئي عبر:

* autoStart: false: لضمان عدم بدء تشغيل الكاميرا إلا عند الطلب.
* \_startScanner(): دالة مخصصة لبدء تشغيل الماسح.
* \_stopScanner(): دالة مخصصة لإيقاف الماسح.

هذا التحكم ضروري لمنع المشاكل الشائعة مثل معالجة نفس الباركود عدة مرات، ولضمان تحرير موارد الكاميرا عند إغلاق الشاشة أو الانتقال إلى شاشة أخرى، مما يحسن أداء التطبيق ويحافظ على البطارية.

🛠️ الدوال الرئيسية ووظائفها

* \_loadLabs: تجلب قائمة المعامل من Firebase لاستخدامها عند تسجيل جهاز جديد.
* \_startScanner / \_stopScanner: تدير دورة حياة الكاميرا بشكل دقيق.
* \_handleBarcodeScan: هي المنسق الرئيسي الذي يتم استدعاؤه عند اكتشاف باركود، وتقوم بتوجيه البيانات إلى المسار الصحيح.
* \_checkDeviceExists: تتواصل مع قاعدة البيانات للتحقق من وجود الجهاز.
* \_showExistingDeviceDialog: تدير واجهة المستخدم في حالة العثور على جهاز موجود.
* \_navigateToNewDeviceRegistration: تدير واجهة المستخدم في حالة عدم العثور على الجهاز.
* build: تبني واجهة المستخدم، وتعرض إما مؤشر تحميل أو واجهة الكاميرا مع أزرار التحكم بالفلاش والكاميرا.
----------------------------------------------------------------------------------------------------------------------------
الشاشة الرئيسية (HomeScreen) - نسخة ذات تخطيط ثابت

📝 نظرة عامة
تمثل هذه الشاشة لوحة التحكم الرئيسية للتطبيق، حيث توفر للمستخدم وصولاً سريعاً إلى المعلومات والوظائف الأساسية. تم إعادة تصميم هذه الشاشة بشكل جذري لحل مشاكل التمرير وتوفير تجربة مستخدم ثابتة وأنيقة، مع فصل المحتوى إلى قسمين رئيسيين عبر نظام تبويبات تفاعلي.

🌊 تدفق البيانات وهيكلة الواجهة (Data Flow & Layout)
تعتمد الشاشة على هيكل ثابت (Fixed Layout) يضمن بقاء العناصر الأساسية في مكانها، مما يوفر تجربة مستخدم أكثر استقراراً.

1. الهيكل العام (Layout Structure)
   تم التخلي عن SingleChildScrollView الذي كان يغطي الشاشة بأكملها، واستبداله بـ Column رأسي يقسم الشاشة إلى ثلاثة أجزاء رئيسية:

* الجزء العلوي الثابت: يحتوي على \_buildUserInfoHeader الذي يعرض معلومات المستخدم ويبقى ظاهراً دائماً.
* الجزء الأوسط المرن: هذا الجزء يستخدم ويدجت Expanded ليملأ أي مساحة متبقية في الشاشة. بداخله، يتم عرض قسم التبويبات.
* الجزء السفلي الثابت: يحتوي على \_buildQuickActions (أزرار الإجراءات السريعة) و \_buildBottomNavBar (شريط التنقل السفلي)، وكلاهما يبقى ثابتاً في مكانه.

هذه الهيكلة تضمن عدم اختفاء الجزء العلوي عند التمرير، لأن التمرير أصبح مقتصراً على القوائم الداخلية فقط.

2. إدارة التبويبات والمحتوى (Tabs & Content Management)
   الزناد: يقوم المستخدم بالضغط على أحد أزرار التبويب ("آخر العمليات" أو "المهام") في \_buildCustomTabBar.

الإجراء:

* يقوم TabController بتسجيل التغيير في التبويبة النشطة.
* يستمع listener المضاف إلى المتحكم لهذا التغيير ويستدعي setState.
* إعادة البناء تصل إلى ويدجت AnimatedSwitcher.

النتيجة:

* تأثير حركي: يقوم AnimatedSwitcher بتنفيذ تأثير تلاشي (Fade) ناعم عند التبديل بين المحتوى القديم والجديد.
* ارتفاع ديناميكي: الأهم من ذلك، أن AnimatedSwitcher يتكيف تلقائياً مع ارتفاع المحتوى الجديد. إذا كانت قائمة المهام أطول من قائمة العمليات، ستتمدد الحاوية بسلاسة لتناسبها، والعكس صحيح. هذا يحل مشكلة قص القائمة بشكل نهائي.

3. تحميل البيانات والتحديث التلقائي (Data Loading & Auto-Refresh)

* التحميل الأولي: عند بدء الشاشة، تستدعي \_loadData لجلب بيانات المعامل والأجهزة، وتوحيدها في قائمة \_recentActivities.
* التحديث عند العودة: عند الانتقال إلى أي شاشة أخرى (مثل إضافة جهاز) والعودة منها، يتم استدعاء \_loadData مرة أخرى بفضل استخدام .then() مع Navigator.push. هذا يضمن أن أي تغييرات جديدة تنعكس فوراً في قائمة "آخر العمليات".

🎭 سيناريوهات الاستخدام المحسّنة

1. التبديل بين العمليات والمهام
   الوصف: يريد المستخدم التنقل بين رؤية آخر الأنشطة التي قام بها والمهام الموكلة إليه.
   الخطوات: يضغط على تبويبة "المهام".
   النتيجة: تختفي قائمة العمليات بسلاسة عبر تأثير تلاشي، وتظهر قائمة المهام مكانها. تتكيف مساحة العرض تلقائياً مع طول قائمة المهام الجديدة دون قص أي عنصر.

2. استعراض قائمة طويلة
   الوصف: إذا كانت قائمة "آخر العمليات" أو "المهام" تحتوي على عناصر أكثر مما تتسع له الشاشة.
   الخطوات: يقوم المستخدم بالتمرير داخل منطقة القائمة.
   النتيجة: يتم تمرير القائمة فقط، بينما يبقى الجزء العلوي (معلومات المستخدم) وشريط التبويب والإجراءات السريعة ثابتين في أماكنهم، مما يوفر تجربة تصفح مستقرة.

🛠️ المكونات والتحسينات الرئيسية

* Column + Expanded: هما أساس التخطيط الثابت والناجح لهذه الشاشة.
* AnimatedSwitcher: هو الحل الذكي الذي يوفر تأثيراً حركياً وارتفاعاً ديناميكياً في آن واحد، مما يحل المشكلتين الرئيسيتين في التصميم السابق.
* \_buildCustomTabBar: ويدجت مخصص يعرض شريط تبويب بتصميم أنيق ومسطح بدون ظلال، مما يمنح الواجهة مظهراً احترافياً.
* قوائم قابلة للتمرير داخلياً: تم تعديل \_buildActivitiesList و \_buildTasksList لتكونا ListView عادية، والتي بطبيعتها قابلة للتمرير إذا تجاوز محتواها المساحة المتاحة لها داخل Expanded.
----------------------------------------------------------------------------------------------------------------------------
شاشة تفاصيل المعمل (LabDetailsScreen)

📝 نظرة عامة
تعمل هذه الشاشة كمركز معلومات متكامل لمعمل معين. تعرض جميع التفاصيل الخاصة بالمعمل، مثل معلوماته الأساسية وحالته وموقعه، بالإضافة إلى قائمة كاملة بجميع الأجهزة المسجلة بداخله. تتيح الشاشة أيضاً للمستخدم الوصول إلى وظائف أخرى مثل تعديل بيانات المعمل أو إضافة جهاز جديد إليه.

🌊 تدفق البيانات وهيكلة الواجهة (Data Flow & Layout)
تتبع الشاشة دورة بيانات بسيطة وموثوقة لضمان عرض معلومات دقيقة ومحدثة.

1. التحميل الأولي (Initial Load)
   الزناد: عند فتح الشاشة، يتم تمرير كائن LabModel إليها. تقوم دالة initState بتشغيل عمليتين متزامنتين:

* \_loadLabDetails(): تقوم بجلب أحدث نسخة من بيانات المعمل من Firebase. هذا يضمن أنه حتى لو تم تعديل بيانات المعمل من قبل مستخدم آخر، فإن الشاشة ستعرض دائماً أحدث المعلومات.
* \_loadDevices(): تقوم بجلب قائمة الأجهزة المرتبطة بمعرف (ID) المعمل الحالي من Firebase. يتم عرض مؤشر تحميل (\_isLoading) أثناء هذه العملية.

النتيجة: يتم عرض تفاصيل المعمل المحدثة وقائمة الأجهزة الخاصة به.

2. عرض البيانات (Data Display)

* معلومات المعمل: يتم عرض التفاصيل في بطاقة معلومات منظمة باستخدام ويدجت مساعد \_buildDetailRow.
* حالة المعمل: يتم استخدام extension على LabStatus لعرض نص وأيقونة ولون مناسبين للحالة الحالية للمعمل (مثل "مفتوح"، "مغلق")، مما يجعل الواجهة أكثر وضوحاً وسهولة في الفهم.
* قائمة الأجهزة:

  * إذا كان المعمل مغلقاً (LabStatus.closed), يتم إخفاء القائمة بالكامل وعرض رسالة توضح أن المعمل مغلق.
  * إذا كان المعمل مفتوحاً ولكن لا توجد به أجهزة، يتم عرض رسالة "لا توجد أجهزة مسجلة".
  * إذا كانت هناك أجهزة، يتم عرضها في ListView، حيث تعرض كل بطاقة (ListTile) معلومات أساسية عن الجهاز وحالة صيانته.

3. التنقل والتحديث التلقائي (Navigation & Auto-Refresh)

* تعديل المعمل: عند الضغط على زر التعديل، ينتقل المستخدم إلى شاشة AddLabScreen. عند العودة، يتم استدعاء \_loadLabDetails() و \_loadDevices() مرة أخرى بفضل استخدام .then()، مما يضمن تحديث أي تغييرات تم إجراؤها.
* إضافة جهاز: عند الضغط على زر الإضافة (+)، ينتقل المستخدم إلى شاشة AddDeviceScreen. عند العودة، يتم استدعاء \_loadDevices() لتحديث قائمة الأجهزة تلقائياً.
* عرض تفاصيل الجهاز: عند الضغط على أي جهاز في القائمة، ينتقل المستخدم إلى شاشة ViewDeviceScreen لعرض تفاصيله الكاملة.

🎭 سيناريوهات الاستخدام (Usage Scenarios)

1. استعراض معمل وحالته
   الوصف: يريد المستخدم معرفة حالة معمل معين وعدد الأجهزة فيه.
   الخطوات:

* يختار المستخدم معملاً من القائمة الرئيسية.
* تُفتح شاشة التفاصيل وتعرض حالة المعمل (مفتوح، مغلق، إلخ) مع أيقونة ولون مميزين.
* يستعرض المستخدم قائمة الأجهزة الموجودة في الأسفل.

2. تعديل معلومات المعمل
   الوصف: يريد المستخدم تغيير حالة معمل من "مفتوح" إلى "مغلق" وإضافة ملاحظات.
   الخطوات:

* يضغط على أيقونة التعديل في شريط العنوان.
* ينتقل إلى شاشة AddLabScreen ويقوم بالتعديلات اللازمة.
* بعد الحفظ، يعود إلى شاشة التفاصيل ويرى أن الحالة والملاحظات قد تم تحديثها.

3. إضافة جهاز جديد إلى المعمل
   الوصف: أثناء تواجده في المعمل، يريد المستخدم تسجيل جهاز جديد بسرعة.
   الخطوات:

* يضغط على أيقونة الإضافة (+) بجانب عنوان "الأجهزة".
* ينتقل إلى شاشة AddDeviceScreen، حيث يكون المعمل محدداً مسبقاً.
* يملأ بيانات الجهاز ويحفظها.
* النتيجة: عند العودة، يظهر الجهاز الجديد فوراً في قائمة الأجهزة بالمعمل.

4. تحديد موقع المعمل
   الوصف: يريد المستخدم معرفة مكان المعمل على الخريطة.
   الخطوات:

* يضغط على زر "فتح الموقع في Google Maps".
* النتيجة: يتم فتح تطبيق خرائط جوجل وتحديد موقع المعمل (أو موقع الكلية كخيار احتياطي).

🛠️ المكونات والتحسينات الرئيسية

* \_loadLabDetails(): دالة مهمة تضمن أن البيانات المعروضة هي دائماً الأحدث من قاعدة البيانات، مما يمنع عرض معلومات قديمة.
* LabStatusExtension: استخدام الـ extension لتجميع المنطق المتعلق بواجهة المستخدم (النص، الأيقونة، اللون) داخل نموذج البيانات نفسه، مما يجعل الكود في واجهة المستخدم أنظف وأكثر قابلية للقراءة.
* منطق عرض مشروط: يتم عرض أو إخفاء أجزاء من الواجهة (مثل زر إضافة جهاز أو قائمة الأجهزة بأكملها) بناءً على حالة المعمل، مما يوفر تجربة مستخدم منطقية.
* التحديث التلقائي: استخدام .then() بعد Navigator.push هو نمط فعال لضمان تحديث البيانات تلقائياً عند العودة من الشاشات الأخرى، مما يحافظ على مزامنة الواجهة مع قاعدة البيانات.
----------------------------------------------------------------------------------------------------------------------------
شاشة قائمة المعامل (LabsListScreen)

📝 نظرة عامة
تعمل هذه الشاشة كواجهة رئيسية لاستعراض جميع المعامل المسجلة في النظام. تم تصميمها لتكون تفاعلية وقوية، حيث تتيح للمستخدمين البحث عن معامل معينة وتصفيتها بناءً على معايير متعددة مثل الكلية، الدور، وحالة المعمل، مع عرض معلومات موجزة ومهمة مثل عدد الأجهزة في كل معمل.

🌊 تدفق البيانات وهيكلة الواجهة (Data Flow & Layout)
تعتمد الشاشة على استراتيجية فعالة لجلب البيانات وعرضها، مما يضمن أداءً جيداً وتجربة مستخدم سلسة.

1. التحميل الأولي وتحسين الأداء
   الزناد: عند فتح الشاشة، تستدعي initState الدالة \_loadLabs.

الإجراء:

* يتم عرض مؤشر تحميل (\_isLoading = true).
* تُجلب قائمتان من Firebase: القائمة الكاملة للمعامل (labs) والقائمة الكاملة للأجهزة (devices).
* تحسين الأداء: بدلاً من البحث عن أجهزة كل معمل على حدة، يتم استدعاء دالة \_calculateLabDeviceCounts مرة واحدة فقط. تقوم هذه الدالة بالمرور على قائمة الأجهزة بأكملها وحساب عدد الأجهزة التابعة لكل معمل، وتخزين النتائج في خريطة (Map) اسمها \_labDeviceCounts. هذا يمنع استدعاءات متكررة ومكلفة لقاعدة البيانات.
* يتم تخزين قائمة المعامل في \_allLabs ونتائج عدد الأجهزة في \_labDeviceCounts.
* تُستدعى \_filterLabs() لتهيئة القائمة المعروضة.

النتيجة: يتم عرض قائمة كاملة بالمعامل، مع عرض عدد الأجهزة بجانب كل معمل بشكل فوري وبدون تأخير.

2. التصفية والبحث (Filtering and Searching)
   الزناد: يتم استدعاء دالة \_filterLabs في حالتين:

* البحث: عند كل تغيير في نص حقل البحث، بفضل المستمع (listener) المضاف إلى \_searchController.
* الفلاتر: عند تطبيق الفلاتر من الورقة السفلية (FilterBottomSheet).

الإجراء المحوري (\_filterLabs):

* تبدأ دائمًا من القائمة الأصلية الكاملة \_allLabs.
* تطبق سلسلة من الشروط المنطقية (&&) لتشمل فقط المعامل التي تطابق جميع الفلاتر المطبقة (نص البحث، الكلية، الدور، والحالة).

النتيجة النهائية هي قائمة جديدة تُخزّن في \_filteredLabs.

النتيجة: يتم تحديث واجهة المستخدم (setState) لعرض القائمة المصفاة فقط، مما يوفر للمستخدم نتائج دقيقة وفورية.

3. واجهة الفلاتر (Filter UI)

* \_showFilterBottomSheet: عند الضغط على أيقونة الفلتر، تعرض هذه الدالة ورقة سفلية قابلة للسحب (DraggableScrollableSheet).
* FilterBottomSheet (ويدجت مستقل): تم فصل واجهة الفلاتر في ويدجت خاص بها لإدارة حالتها المؤقتة (\_temp... variables) بشكل مستقل. هذا يعني أن التغييرات داخل الفلاتر لا تؤثر على القائمة الرئيسية إلا بعد الضغط على زر "تطبيق".
* دالة رد الاتصال (onApplyFilters): عند الضغط على "تطبيق"، تقوم FilterBottomSheet باستدعاء هذه الدالة لتمرير الاختيارات النهائية إلى الشاشة الرئيسية، التي تقوم بدورها بتحديث حالتها وتطبيق التصفية.

4. التنقل والتحديث التلقائي
   الزناد: يضغط المستخدم على بطاقة معمل للانتقال إلى تفاصيله، أو على زر "إضافة" لإنشاء معمل جديد.

الإجراء: يتم الانتقال إلى شاشة LabDetailsScreen أو AddLabScreen باستخدام Navigator.push.

النتيجة: بفضل استخدام .then((\_) => \_loadLabs())، يتم إعادة تحميل قائمة المعامل بالكامل عند عودة المستخدم من أي شاشة أخرى. هذا يضمن أن أي تعديلات أو إضافات جديدة تنعكس فوراً في القائمة.

🎭 سيناريوهات الاستخدام

1. استعراض المعامل
   الوصف: يريد المستخدم رؤية جميع المعامل المتاحة وحالتها وعدد الأجهزة في كل منها.
   الخطوات: يفتح الشاشة ويرى القائمة الكاملة.
   النتيجة: يحصل على نظرة سريعة ومنظمة، مع تمييز بصري لحالة كل معمل (أخضر، برتقالي، أحمر) وشارة توضح عدد الأجهزة.

2. البحث عن معمل معين
   الوصف: يريد المستخدم العثور على "معمل 101" بسرعة.
   الخطوات: يكتب "101" في حقل البحث.
   النتيجة: تتقلص القائمة في الوقت الفعلي لتُظهر المعمل المطابق فقط.

3. تصفية متقدمة
   الوصف: يريد المستخدم رؤية جميع المعامل "المغلقة" في "كلية الهندسة".
   الخطوات:

* يضغط على أيقونة الفلتر.
* يختار "كلية الهندسة" من قائمة الكليات.
* يختار "مغلق" من خيارات الحالة.
* يضغط على "تطبيق الفلاتر".
  النتيجة: تعرض الشاشة قائمة دقيقة بالمعامل التي تطابق هذه الشروط.

🛠️ المكونات والتحسينات الرئيسية

* \_allLabs مقابل \_filteredLabs: استراتيجية القائمتين التي تسمح بتصفية فعالة دون الحاجة إلى إعادة جلب البيانات من قاعدة البيانات مع كل تغيير.
* \_calculateLabDeviceCounts: تحسين كبير في الأداء عن طريق حساب عدد الأجهزة مرة واحدة عند التحميل الأولي، بدلاً من حسابها لكل عنصر في القائمة بشكل متكرر.
* FilterBottomSheet: فصل واجهة الفلاتر في ويدجت مستقل يجعل الكود أكثر تنظيماً وقابلية للصيانة.
* ويدجتات مساعدة (\_build...): استخدام دوال مساعدة مثل \_buildLabItem و \_buildDeviceCountBadge يجعل دالة build الرئيسية نظيفة وسهلة القراءة.
----------------------------------------------------------------------------------------------------------------------------
شاشة عرض المعامل (LabsScreen)

📝 نظرة عامة
تعمل هذه الشاشة كواجهة رئيسية لاستعراض جميع المعامل المسجلة في النظام. تم تصميمها لتكون بسيطة وفعالة، حيث تتيح للمستخدمين تصفية المعامل بسهولة بناءً على الكلية والدور، مع عرض معلومات أساسية عن كل معمل وحالته بشكل مرئي وواضح.

🌊 تدفق البيانات وهيكلة الواجهة (Data Flow & Layout)
تعتمد الشاشة على استراتيجية تصفية مباشرة عند جلب البيانات لضمان عرض المعلومات ذات الصلة فقط.

1. التحميل الأولي والتصفية (Initial Load & Filtering)
   الزناد: عند فتح الشاشة، تستدعي initState الدالة \_loadLabs.

الإجراء:

* يتم عرض مؤشر تحميل (\_isLoading = true).
* تُستدعى دالة \_fetchFilteredLabs التي تحتوي على منطق التصفية.
* التصفية على مستوى قاعدة البيانات: إذا اختار المستخدم كلية معينة، يتم جلب المعامل التابعة لهذه الكلية فقط من Firebase (getLabsByCollege). أما إذا كان الخيار "جميع الكليات"، فيتم جلب جميع المعامل (getLabs).
* التصفية في الذاكرة: بعد جلب البيانات، يتم تطبيق فلتر "الدور" على النتائج التي تم الحصول عليها.

النتيجة: يتم تحديث قائمة \_labs بالبيانات المصفاة، ثم يتم عرضها للمستخدم. هذه الطريقة تقلل من كمية البيانات المنقولة من قاعدة البيانات إذا تم تحديد كلية.

2. إعادة التحميل عند تغيير الفلاتر
   الزناد: عندما يغير المستخدم قيمة أي من القوائم المنسدلة (الكلية أو الدور).

الإجراء: يتم استدعاء دالة \_loadLabs مرة أخرى.

النتيجة: يتم تكرار عملية جلب البيانات وتصفيتها من جديد بناءً على الاختيارات الجديدة، مما يضمن أن القائمة المعروضة تعكس دائماً الفلاتر المطبقة.

3. معالجة الأخطاء (Error Handling)
   الزناد: في حال فشل عملية جلب البيانات من Firebase.

الإجراء:

* تُستدعى دالة \_handleLoadError.
* يتم عرض ورقة سفلية (BottomSheet) للمستخدم تحتوي على خيارين: "إعادة المحاولة" (التي تستدعي \_loadLabs مرة أخرى) و "تفاصيل الخطأ".

النتيجة: توفير تجربة مستخدم أفضل عند حدوث مشاكل في الشبكة، مع إعطاء المستخدم القدرة على إعادة المحاولة أو معرفة سبب المشكلة.

4. التنقل (Navigation)

* إضافة معمل: عند الضغط على الزر العائم (+)، ينتقل المستخدم إلى شاشة AddLabScreen لإنشاء معمل جديد.
* تفاصيل المعمل: عند الضغط على بطاقة أي معمل في القائمة، يتم التحقق أولاً من وجود رابط للموقع. إذا لم يكن موجوداً، تظهر رسالة خطأ. إذا كان موجوداً، ينتقل المستخدم إلى شاشة LabDetailsScreen لعرض التفاصيل الكاملة.

🎭 سيناريوهات الاستخدام

1. استعراض معامل كلية معينة
   الوصف: يريد المستخدم رؤية جميع معامل "كلية الحاسب الآلي" فقط.
   الخطوات:

* يفتح الشاشة.
* يختار "كلية الحاسب الآلي" من القائمة المنسدلة للكلية.

النتيجة: يتم تحديث القائمة تلقائياً لعرض معامل هذه الكلية فقط.

2. العثور على معامل في دور معين
   الوصف: يريد المستخدم رؤية جميع المعامل الموجودة في "الدور الأول" داخل كلية معينة.
   الخطوات:

* يختار الكلية المطلوبة.
* يختار "الدور الأول" من القائمة المنسدلة للدور.

النتيجة: يتم تصفية القائمة المعروضة لتشمل فقط معامل الدور الأول في تلك الكلية.

3. إضافة معمل جديد
   الوصف: يريد المستخدم إضافة معمل غير مسجل.
   الخطوات: يضغط على الزر العائم (+) في أسفل الشاشة.

النتيجة: ينتقل إلى شاشة إضافة معمل جديدة.

🛠️ المكونات والتحسينات الرئيسية

* التصفية المزدوجة: استخدام استراتيجية تصفية تجمع بين جلب البيانات المحددة من قاعدة البيانات (حسب الكلية) والتصفية اللاحقة في الذاكرة (حسب الدور).
* معالجة الأخطاء التفاعلية: بدلاً من عرض رسالة خطأ ثابتة، يتم عرض خيارات تفاعلية للمستخدم عبر BottomSheet، مما يحسن تجربة المستخدم.
* التحقق قبل التنقل: يتم التحقق من وجود بيانات أساسية (مثل رابط الموقع) قبل السماح للمستخدم بالانتقال إلى شاشة التفاصيل، مما يمنع حدوث أخطاء غير متوقعة.
* ويدجتات مساعدة (\_build...): استخدام دوال مساعدة مثل \_buildLabItem و \_buildDropdown يجعل دالة build الرئيسية نظيفة ومنظمة وسهلة القراءة.
----------------------------------------------------------------------------------------------------------------------------
شاشة عرض تفاصيل الجهاز (ViewDeviceScreen)

📝 نظرة عامة
تعمل هذه الشاشة كصفحة ملف شخصي (Profile Page) لجهاز معين. هي شاشة مخصصة للعرض فقط، حيث تقدم جميع المعلومات المسجلة عن جهاز واحد بطريقة منظمة ومفصلة، موزعة على بطاقات متعددة. توفر الشاشة أيضاً نقطة انطلاق لتعديل بيانات هذا الجهاز عبر زر مخصص في شريط العنوان.

🌊 تدفق البيانات وهيكلة الواجهة (Data Flow & Layout)
تتبع الشاشة دورة بيانات بسيطة تهدف إلى ضمان عرض أحدث المعلومات المتاحة للجهاز.

1. التحميل الأولي والتحديث التلقائي
   الزناد: عند فتح الشاشة، يتم تمرير كائن DeviceModel إليها. تقوم دالة initState فوراً باستدعاء \_loadDeviceAndLabDetails.

الإجراء:

* جلب البيانات المحدثة: تقوم الدالة بإعادة جلب بيانات الجهاز الكاملة من Firebase باستخدام معرفه (ID). هذا الإجراء مهم جداً لضمان أن المعلومات المعروضة هي الأحدث، حتى لو قام مستخدم آخر بتعديلها.
* جلب تفاصيل المعمل: بعد الحصول على بيانات الجهاز المحدثة، يتم استخدام labId لجلب تفاصيل المعمل المرتبط به.
* يتم عرض مؤشر تحميل (\_isLoading) أثناء هذه العمليات.

النتيجة: يتم تحديث الحالة (setState) وعرض التفاصيل الكاملة والمحدثة للجهاز والمعمل.

2. عرض البيانات المشروط (Conditional UI)

* صورة الجهاز: لا يتم عرض قسم الصورة إلا إذا كان الجهاز يحتوي على رابط صورة صالح (يبدأ بـ http). هذا يمنع ظهور أخطاء أو مساحات فارغة غير مرغوب فيها.
* تفاصيل المعمل: لا يتم عرض بطاقة معلومات المعمل إلا إذا كان الجهاز مرتبطاً بمعمل (\_associatedLab ليس null).
* الملاحظات: لا يتم عرض بطاقة الملاحظات إلا إذا كانت تحتوي على نص (notes.isNotEmpty).

هذا المنطق يجعل الواجهة نظيفة وذكية، حيث تعرض فقط الأقسام التي تحتوي على بيانات فعلية.

3. التنقل والتحديث عند العودة
   الزناد: يضغط المستخدم على أيقونة التعديل في شريط العنوان.

الإجراء: يتم الانتقال إلى شاشة AddDeviceScreen، مع تمرير كائن \_currentDevice لملء حقول التعديل.

الأهم: تم إرفاق دالة .then((\_) => \_loadDeviceAndLabDetails()) مع عملية الانتقال.

النتيجة: عند عودة المستخدم من شاشة التعديل (بعد الحفظ أو الإلغاء)، يتم استدعاء دالة التحميل مرة أخرى تلقائياً، مما يضمن أن أي تعديلات قام بها المستخدم تنعكس فوراً على شاشة التفاصيل بدون الحاجة إلى تحديث يدوي.

🎭 سيناريوهات الاستخدام

1. استعراض تفاصيل جهاز بالكامل
   الوصف: يريد المستخدم رؤية جميع مواصفات جهاز معين ومكانه وحالته.

الخطوات:

* يضغط المستخدم على جهاز من أي قائمة (مثل قائمة الأجهزة في معمل أو قائمة البحث).

النتيجة: تفتح الشاشة وتعرض كل شيء عن هذا الجهاز في مكان واحد منظم، من مواصفاته الفنية إلى المعمل الذي ينتمي إليه.

2. التحقق من حالة الصيانة
   الوصف: يريد المستخدم التحقق مما إذا كان جهاز معين يحتاج إلى صيانة ورؤية صورة توضح المشكلة.

الخطوات:

* يفتح شاشة تفاصيل الجهاز.

النتيجة: يرى حالة الصيانة بلون مميز (برتقالي أو أخضر). إذا كان الجهاز يحتاج صيانة وهناك صورة مرفقة، ستظهر الصورة في أعلى الشاشة ويمكن تكبيرها بالضغط عليها.

3. تعديل بيانات الجهاز
   الوصف: يلاحظ المستخدم أن هناك خطأ في الرقم التسلسلي للجهاز ويريد تصحيحه.

الخطوات:

* يضغط على أيقونة التعديل في شريط العنوان.
* ينتقل إلى شاشة AddDeviceScreen ويقوم بتصحيح الرقم.
* بعد الحفظ، يعود إلى شاشة التفاصيل.

النتيجة: يرى أن الرقم التسلسلي قد تم تحديثه تلقائياً في شاشة التفاصيل.

🛠️ المكونات والتحسينات الرئيسية

* \_loadDeviceAndLabDetails(): دالة محورية تضمن أن البيانات المعروضة هي دائماً "مصدر الحقيقة" الأحدث من قاعدة البيانات.
* العرض المشروط: استخدام الشروط (if) في دالة build لعرض المكونات فقط عند الحاجة، مما يجعل الواجهة أكثر ذكاءً ونظافة.
* التحديث التلقائي عند العودة (then): نمط فعال يوفر تجربة مستخدم سلسة ويحافظ على تزامن البيانات بين الشاشات المختلفة.
* ويدجتات مساعدة (\_build...Card): تقسيم الواجهة إلى بطاقات منفصلة، كل منها في دالة خاصة، يجعل الكود منظماً وسهل القراءة والصيانة.
----------------------------------------------------------------------------------------------------------------------------
شاشة الإعدادات (SettingsScreen)

📝 نظرة عامة
هذه الشاشة مخصصة لتكون مركز التحكم في إعدادات التطبيق المستقبلية. في حالتها الحالية، تم تبسيطها بشكل كبير لتعمل كحاضنة (Placeholder) للإعدادات التي قد يتم إضافتها لاحقاً.

🏛️ الهيكلة والوظيفة الحالية

* البساطة: تم تصميم الشاشة لتكون بسيطة جداً، حيث تتكون من شريط عنوان (AppBar) وقائمة قابلة للتمرير (ListView).
* حذف الوظائف المؤقتة: تم إزالة الوظائف التجريبية التي كانت موجودة سابقاً، مثل "إعادة إنشاء قاعدة البيانات" و "تصدير البيانات". تم حذف هذه الوظائف لأنها كانت مخصصة لأغراض التطوير والاختبار فقط وليست جزءاً من الميزات النهائية للمستخدم.
* الواجهة الحالية: تعرض الشاشة حالياً بطاقة (Card) واحدة فقط، تخبر المستخدم بأنه "لا توجد إعدادات متاحة حاليًا"، وتوضح أن هذه الشاشة مخصصة للإضافات المستقبلية.

🎭 سيناريو الاستخدام الحالي
الوصف: يصل المستخدم إلى شاشة الإعدادات من خلال شريط التنقل السفلي.

الخطوات:

* يضغط المستخدم على أيقونة "الإعدادات".

النتيجة: تفتح الشاشة وتعرض رسالة توضيحية بأنها فارغة حالياً، مما يدير توقعات المستخدم ويوضح أن هذه المنطقة قيد التطوير.

🚀 التطوير المستقبلية
هذه الشاشة هي الأساس الذي يمكن البناء عليه لإضافة العديد من الميزات، مثل:

* إعدادات حساب المستخدم (تغيير كلمة المرور، تعديل المعلومات الشخصية).
* إعدادات الإشعارات.
* اختيار الثيم (Theme) للتطبيق (داكن/فاتح).
* إعدادات اللغة.
* صفحة "عن التطبيق" أو "تواصل معنا".
----------------------------------------------------------------------------------------------------------------------------
خدمة قاعدة البيانات (FirebaseDatabaseService)

📝 نظرة عامة
يعتبر كلاس FirebaseDatabaseService هو الطبقة المسؤولة عن عزل منطق التعامل مع قاعدة البيانات (Data Layer) عن باقي أجزاء التطبيق. يوفر هذا الكلاس مجموعة من الدوال الثابتة (static) التي تعمل كواجهة برمجية (API) داخلية للتفاعل مع خدمات Firebase، وتحديداً Firestore (لتخزين البيانات المنظمة) و Storage (لتخزين الملفات مثل الصور).

هذا التصميم يتبع مبدأ فصل الاهتمامات (Separation of Concerns)، حيث أن واجهة المستخدم (UI) لا تتواصل مباشرة مع Firebase، بل تستدعي دوال هذا الكلاس، مما يجعل الكود أكثر تنظيماً وسهولة في الصيانة والتطوير.

🌊 تدفق العمليات والمسؤوليات
ينقسم الكلاس إلى ثلاث مسؤوليات رئيسية:

* عمليات المعامل (Labs): إدارة كل ما يتعلق بإنشاء، قراءة، تحديث، وحذف بيانات المعامل.
* عمليات الأجهزة (Devices): إدارة كل ما يتعلق ببيانات الأجهزة، بما في ذلك ربطها بالمعامل.
* عمليات تخزين الملفات (Storage): توفير دوال عامة لرفع وحذف الصور من Firebase Storage.

🛠️ الوظائف الرئيسية بالتفصيل

1. عمليات المعامل (Labs)

* addOrUpdateLab(LabModel lab): دالة ذكية تقوم بإضافة معمل جديد أو تحديث بيانات معمل موجود باستخدام set مع SetOptions(merge: true). تتعامل أيضاً مع رفع صورة المعمل إذا تم توفير مسار ملف محلي.
* deleteLab(String labId): تقوم بعملية حذف شاملة؛ حيث لا تكتفي بحذف مستند المعمل من Firestore، بل تقوم أيضاً بتحديث جميع الأجهزة التي كانت مرتبطة به (عبر تعيين labId إلى null) وحذف صورة المعمل من Storage.
* updateLabStatus(String labId): دالة تلقائية تقوم بتحديث حالة المعمل (مثل openWithDevices أو openNoDevices) بناءً على عدد الأجهزة المرتبطة به حالياً. تُستدعى هذه الدالة تلقائياً بعد إضافة أو حذف جهاز.
* getLabs(): تجلب قائمة بجميع المعامل المسجلة.
* getLabsByCollege(String college): دالة تصفية تجلب المعامل التابعة لكلية معينة فقط، مما يحسن الأداء عن طريق تقليل كمية البيانات المنقولة.
* getLabById(String labId): تجلب بيانات معمل واحد محدد.

2. عمليات الأجهزة (Devices)

* addOrUpdateDevice(DeviceModel device): على غرار المعامل، تقوم بإضافة أو تحديث جهاز. الميزة الإضافية هنا هي أنها تستدعي updateLabStatus تلقائياً بعد العملية لضمان تحديث حالة المعمل المرتبط.
* deleteDevice(String deviceId): تقوم بحذف الجهاز، وتحصل على بياناته أولاً لمعرفة المعمل المرتبط به وتحديث حالته، كما تقوم بحذف صورة الجهاز من Storage.
* getDeviceById(String deviceId): تجلب بيانات جهاز واحد محدد.
* getDevices(): تجلب قائمة بجميع الأجهزة.
* getDevicesForLab(String labId): تجلب قائمة الأجهزة الموجودة في معمل معين.
* serialNumberExists(...): دالة مهمة لضمان سلامة البيانات، حيث تتحقق مما إذا كان الرقم التسلسلي موجوداً مسبقاً قبل السماح بإضافة جهاز جديد، مع إمكانية استثناء جهاز معين عند التحديث.
* getDeviceByBarcode(...): دالة بحث متخصصة تبحث عن جهاز باستخدام الباركود الجامعي أو رمز الأصل، وتقوم بإجراء استعلامين منفصلين لأن Firestore لا يدعم استعلام OR على حقول مختلفة.

3. عمليات تخزين الصور (Firebase Storage)

* uploadImageToFirebaseStorage(...): دالة عامة وقابلة لإعادة الاستخدام، تأخذ ملف صورة ومسار تخزين، وتقوم برفعه إلى Firebase Storage ثم تُرجع رابط التحميل (URL) الخاص به لتخزينه في Firestore.
* \_deleteImageFromFirebaseStorage(...): دالة مساعدة خاصة (private) تُستخدم داخلياً لحذف الصور عند حذف المعمل أو الجهاز المرتبط بها.

🛡️ استراتيجية معالجة الأخطاء

* try-catch: جميع الدوال التي تتفاعل مع الشبكة (Firebase) محاطة بكتل try-catch لمعالجة أي أخطاء محتملة مثل انقطاع الاتصال.
* rethrow: في حالة حدوث خطأ، تقوم معظم الدوال بإعادة رمي الخطأ (rethrow). هذا يسمح للطبقة العليا (واجهة المستخدم) بالتقاط الخطأ وعرض رسالة مناسبة للمستخدم (مثل SnackBar أو مربع حوار)، بدلاً من انهيار التطبيق بصمت.
* debugPrint: يتم استخدام debugPrint لتسجيل معلومات مفيدة ورسائل خطأ في وحدة التحكم أثناء التطوير، مما يساعد في تتبع المشاكل وإصلاحها.
----------------------------------------------------------------------------------------------------------------------------
ملف أدوات الباركود (BarcodeUtils)

📝 نظرة عامة
يعتبر كلاس BarcodeUtils بمثابة "صندوق أدوات" خدمي (Utility Class) مخصص للتعامل مع كل ما يتعلق بالباركود في التطبيق. تم تصميمه ككلاس يحتوي على دوال ثابتة (static) فقط، مما يعني أنه لا يمكن إنشاء كائن منه، بل يتم استدعاء دواله مباشرة من أي مكان في الكود.

الهدف الأساسي من هذا الكلاس هو مركزية منطق الباركود في مكان واحد، مما يحقق الفوائد التالية:

* إعادة الاستخدام: يمكن استخدام نفس دوال التحليل والتحقق في شاشات متعددة (مثل شاشة الماسح الضوئي أو شاشة إضافة جهاز يدوياً).
* سهولة الصيانة: إذا تغير منطق تحليل الباركود في المستقبل، يتم تعديله في هذا الملف فقط بدلاً من البحث عنه في عدة أماكن.
* نظافة الكود: يجعل الكود في الشاشات الأخرى أكثر نظافة وتركيزاً على واجهة المستخدم، حيث يتم تفويض مهام الباركود إلى هذا الكلاس.

🛠️ الوظائف الرئيسية بالتفصيل

1. parseUniversityBarcode(Barcode barcode)

* الوظيفة: هي الدالة الرئيسية لتحليل الباركود. تأخذ كائن Barcode الذي يتم الحصول عليه من مكتبة mobile\_scanner وتحوله إلى بيانات منظمة ومفهومة للتطبيق.
* المدخلات: كائن Barcode.
* المخرجات: تُرجع خريطة (Map\<String, String?>) تحتوي على الحقول التالية:

  * 'barcode': القيمة النصية الخام للباركود كما هي.
  * 'assetSource': مصدر الأصل، حالياً تم تعيينه بقيمة ثابتة "جامعة أم القرى".
  * 'assetCategory': فئة الأصل، يتم تحديدها عبر استدعاء دالة مساعدة خاصة.
  * 'assetCode': رمز الأصل، حالياً يتم استخدام قيمة الباركود الخام كرمز للأصل لتبسيط التطبيق.

2. \_determineAssetCategory(String barcodeValue)

* الوظيفة: دالة مساعدة خاصة (private) تُستخدم داخلياً بواسطة parseUniversityBarcode. تحتوي على منطق عمل بسيط لتحديد فئة الأصل بناءً على كلمات مفتاحية في نص الباركود.
* المنطق الحالي:

  * إذا كان النص يحتوي على كلمة computer، تُرجع "معدات حاسب".
  * إذا كان النص يحتوي على كلمة lab، تُرجع "معدات معملية".
  * إذا لم يتطابق أي شرط، تُرجع فئة افتراضية "معدات عامة".
* ملاحظة: هذا المنطق هو مثال مبسط ويمكن تطويره مستقبلاً ليشمل قواعد أكثر تعقيداً.

3. isValidBarcode(String? barcodeValue)

* الوظيفة: دالة بسيطة للتحقق من صحة سلسلة نصية تمثل باركود.
* المنطق الحالي: تتحقق من أن النص ليس فارغاً (null أو empty) وأن طوله لا يقل عن 5 أحرف.
* الاستخدام: يمكن استخدامها للتحقق من صحة الباركود المدخل يدوياً من قبل المستخدم.

4. generateAssetCode(String baseCode)

* الوظيفة: دالة لإنشاء رمز أصل موحد ومتسق.
* المنطق الحالي: تأخذ رمزاً أساسياً وتضيف إليه بادئة ثابتة (UQU-) وسنة الإدخال الحالية.
* مثال: إذا كان الإدخال 12345، سيكون الناتج UQU-2025-12345.

🚀 كيفية الاستخدام
بما أن جميع الدوال ثابتة، يمكنك استدعاؤها مباشرة من أي مكان كالتالي:

// في شاشة الماسح الضوئي بعد اكتشاف باركود
final Barcode detectedBarcode = ...;
final Map\<String, String?> parsedData = BarcodeUtils.parseUniversityBarcode(detectedBarcode);
print(parsedData\['assetCategory']); // سيطبع "معدات حاسب" أو غيرها

// في شاشة إضافة جهاز عند التحقق من إدخال يدوي
String userInput = '123456';
if (BarcodeUtils.isValidBarcode(userInput)) {
// الباركود صالح
}

----------------------------------------------------------------------------------------------------------------------------
ملف أدوات الصور (ImageUtils)

📝 نظرة عامة
يعتبر كلاس ImageUtils بمثابة "صندوق أدوات" خدمي (Utility Class) مخصص للتعامل مع كل ما يتعلق بالصور في التطبيق. تم تصميمه ككلاس يحتوي على دوال ثابتة (static) فقط، مما يعني أنه لا يمكن إنشاء كائن منه، بل يتم استدعاء دواله مباشرة من أي مكان في الكود.

الهدف الأساسي من هذا الكلاس هو مركزية منطق معالجة الصور في مكان واحد، مما يحقق الفوائد التالية:

* إعادة الاستخدام: يمكن استخدام نفس دوال التقاط وضغط الصور في شاشات متعددة (مثل شاشة إضافة جهاز أو شاشة إضافة معمل).
* سهولة الصيانة: إذا تغيرت طريقة ضغط الصور أو التحقق منها، يتم تعديلها في هذا الملف فقط.
* نظافة الكود: يجعل الكود في الشاشات الأخرى أكثر نظافة وتركيزاً على واجهة المستخدم، حيث يتم تفويض مهام الصور المعقدة إلى هذا الكلاس.

🛠️ الوظائف الرئيسية بالتفصيل

1. pickImage(...)

* الوظيفة: هي الدالة الرئيسية لالتقاط صورة جديدة. توفر واجهة موحدة للتعامل مع مكتبة image\_picker مع إضافة وظائف إضافية.
* المدخلات:

  * source: يحدد مصدر الصورة (افتراضياً ImageSource.camera).
  * maxWidth, maxHeight, imageQuality: خيارات لتغيير حجم وجودة الصورة مباشرة عند الالتقاط.
  * maxSizeInBytes: حد أقصى لحجم الملف. إذا كانت الصورة الملتقطة أكبر من هذا الحجم، تقوم الدالة بإلقاء استثناء (Exception) برسالة واضحة للمستخدم.
* الإجراء:

  * تستخدم ImagePicker لفتح الكاميرا أو المعرض.
  * تتحقق من حجم الملف إذا كان الشرط مطلوباً.
  * تستدعي \_saveImagePermanently لحفظ نسخة من الصورة في مساحة تخزين آمنة خاصة بالتطبيق.
* المخرجات: تُرجع كائن File يمثل الصورة الملتقطة والمحفوظة، أو null إذا ألغى المستخدم العملية.

2. \_saveImagePermanently(File image)

* الوظيفة: دالة مساعدة خاصة (private) تضمن عدم فقدان الصورة الملتقطة. تقوم بنسخ الصورة من المجلد المؤقت (الذي قد يحذفه النظام) إلى مجلد المستندات الدائم الخاص بالتطبيق.
* لماذا هي مهمة؟ تمنع حدوث أخطاء حيث يتم حذف الصورة الأصلية بواسطة نظام التشغيل قبل أن يتم رفعها إلى قاعدة البيانات.

3. compressImage(File file, {int quality = 85})

* الوظيفة: تقوم بضغط ملف صورة معين لتقليل حجمه بشكل كبير قبل رفعه إلى Firebase Storage.
* الإجراء:

  * تستخدم مكتبة flutter\_image\_compress القوية لتنفيذ الضغط.
  * تقوم بتغيير أبعاد الصورة إلى حجم معقول (1080x720) لضمان عدم استهلاك مساحة تخزين كبيرة.
  * تحفظ الصورة المضغوطة في ملف جديد باسم فريد.
* المخرجات: تُرجع كائن File يمثل الصورة المضغوطة، أو null في حالة فشل العملية.

4. isValidImage(File? image, {int? maxSizeInMB})

* الوظيفة: دالة بسيطة للتحقق من صحة ملف صورة.
* المنطق الحالي: تتحقق من أن الملف ليس فارغاً (null)، وأنه موجود فعلياً على الجهاز، ويمكنها أيضاً التحقق من أن حجمه لا يتجاوز حداً معيناً بالميجابايت.

5. generateUniqueFileName()

* الوظيفة: دالة مساعدة لإنشاء اسم ملف فريد لتجنب تضارب الأسماء.
* المنطق الحالي: تستخدم الطابع الزمني الحالي (Timestamp) لضمان أن كل اسم ملف فريد.

🚀 كيفية الاستخدام
بما أن جميع الدوال ثابتة، يمكنك استدعاؤها مباشرة من أي مكان في التطبيق.

مثال على التقاط صورة:
// في أي StatefulWidget
Future<void> \_takePicture() async {
try {
final File? image = await ImageUtils.pickImage(
context: context,
source: ImageSource.camera,
maxSizeInBytes: 5 \* 1024 \* 1024, // 5 MB
);

```
if (image != null) {
  // يمكنك الآن ضغط الصورة قبل رفعها
  final File? compressedImage = await ImageUtils.compressImage(image);
  
  if (compressedImage != null) {
    setState(() {
      // تحديث متغير الحالة بالصورة المضغوطة
      _myImageFile = compressedImage;
    });
  }
}
```

} catch (e) {
// عرض رسالة الخطأ للمستخدم
ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(e.toString())));
}
}

----------------------------------------------------------------------------------------------------------------------------
ملف أدوات واجهة المستخدم (UIHelpers)

📝 نظرة عامة
يعتبر كلاس UIHelpers بمثابة "صندوق أدوات" مركزي وموحد لجميع التفاعلات الشائعة مع واجهة المستخدم في التطبيق. تم تصميمه ككلاس خدمي (Utility Class) يحتوي على دوال ثابتة (static) فقط، مما يسمح باستدعائها مباشرة من أي شاشة دون الحاجة لإنشاء كائن منه.

الهدف الأساسي من هذا الكلاس هو توحيد تجربة المستخدم وتقليل تكرار الكود من خلال توفير دوال جاهزة ومصممة بشكل جيد للمهام التالية:

* عرض رسائل للمستخدم (Snackbars) بأنواع وألوان مختلفة.
* عرض مربعات حوار (Dialogs) متنوعة مثل رسائل التأكيد، مؤشرات التحميل، وعرض الصور.
* عرض قوائم خيارات متقدمة وقابلة للتخصيص (Bottom Sheets).

🛠️ الوظائف الرئيسية بالتفصيل

1. عرض الرسائل (showSnackBar)

* الوظيفة: دالة مرنة لعرض رسائل قصيرة للمستخدم في أسفل الشاشة.
* الميزات:

  * SnackBarType (Enum): تستخدم هذا التعداد لتحديد نوع الرسالة (success, error, warning, info). بناءً على النوع، يتم تغيير لون الخلفية والأيقونة تلقائياً لتوفير تغذية راجعة بصرية واضحة.
  * تصميم محسن: يتم عرض الـ SnackBar كبطاقة عائمة بحواف دائرية، مما يعطي مظهراً عصرياً.
  * دوال مساعدة: يوفر الكلاس اختصارات مثل showErrorSnackBar و showSuccessSnackBar لتبسيط استدعاء الأنواع الشائعة.

2. مربعات الحوار (Dialogs)

* showConfirmationDialog(...): لعرض مربع حوار بسيط يطلب من المستخدم تأكيد إجراء معين (مثل الحذف). تُرجع true عند التأكيد و false عند الإلغاء.
* showLoadingDialog(...): لعرض مؤشر تحميل لا يمكن للمستخدم إغلاقه، مما يمنعه من التفاعل مع التطبيق أثناء تنفيذ عملية تستغرق وقتاً.
* showCustomDialog(...): دالة مرنة تسمح بعرض أي ويدجت مخصص داخل مربع حوار، مما يوفر إمكانيات غير محدودة.
* showImageDialog(...): دالة متخصصة لعرض الصور في وضع ملء الشاشة.

  * متعددة المصادر: تقبل الصورة كملف محلي (File) أو كرابط من الإنترنت (String).
  * تفاعلية: تستخدم ويدجت InteractiveViewer للسماح للمستخدم بتكبير الصورة وتحريكها بحرية.

3. الورقة السفلية للخيارات (showBottomSheetOptions)

* الوظيفة: هي أقوى دالة في هذا الكلاس، حيث تعرض ورقة سفلية (Bottom Sheet) قابلة للسحب وتغيير الحجم لعرض قائمة من الخيارات.
* الميزات المتقدمة:

  * BottomSheetOption (Class): كلاس بيانات بسيط لتعريف كل خيار (العنوان، الأيقونة، والإجراء عند النقر).
  * القوائم المتداخلة: تدعم الدالة عرض قوائم متداخلة. إذا كان أحد الخيارات يحتوي على قائمة options فرعية، فإن الضغط عليه سيفتح ورقة سفلية جديدة بنفس الخيارات الفرعية، مما يسمح بإنشاء قوائم معقدة.
  * بحث (اختياري): يمكن تفعيل شريط بحث لتصفية الخيارات المعروضة.

🚀 كيفية الاستخدام
بما أن جميع الدوال ثابتة، يمكنك استدعاؤها مباشرة من أي مكان في التطبيق لديه BuildContext.

مثال على عرض رسالة نجاح:
// بعد عملية حفظ ناجحة
UIHelpers.showSuccessSnackBar(context, 'تم حفظ الجهاز بنجاح');

مثال على طلب تأكيد الحذف:
Future<void> \_deleteItem() async {
final bool? confirmed = await UIHelpers.showConfirmationDialog(
context: context,
title: 'تأكيد الحذف',
content: 'هل أنت متأكد من حذف هذا العنصر؟',
confirmColor: Colors.red,
);

if (confirmed == true) {
// تنفيذ عملية الحذف
}
}

مثال على عرض خيارات:
UIHelpers.showBottomSheetOptions(
context: context,
title: 'خيارات إضافية',
options: \[
BottomSheetOption(
title: 'تعديل',
icon: Icon(Icons.edit),
onTap: () { /\* تنفيذ التعديل */ },
),
BottomSheetOption(
title: 'حذف',
icon: Icon(Icons.delete, color: Colors.red),
onTap: () { /* تنفيذ الحذف \*/ },
),
],
);

----------------------------------------------------------------------------------------------------------------------------
ملف أدوات التحقق (ValidationUtils)

📝 نظرة عامة
يعتبر كلاس ValidationUtils بمثابة "مكتبة التحقق" المركزية للتطبيق. تم تصميمه ككلاس خدمي (Utility Class) يحتوي على مجموعة من الدوال الثابتة (static) التي يمكن استدعاؤها من أي مكان للتحقق من صحة مدخلات المستخدم في النماذج (Forms).

الهدف الأساسي من هذا الكلاس هو توحيد منطق التحقق من الصحة في مكان واحد، مما يحقق الفوائد التالية:

* إعادة الاستخدام: يمكن استخدام نفس دالة التحقق (مثل validateName) في شاشات متعددة، مما يمنع تكرار الكود.
* الاتساق: يضمن أن رسائل الخطأ وشروط التحقق متسقة في جميع أنحاء التطبيق، مما يوفر تجربة مستخدم موحدة.
* سهولة الصيانة: إذا تغيرت قاعدة التحقق من صحة حقل معين (مثل تغيير طول الرقم التسلسلي)، يتم تعديلها في هذا الملف فقط.
* نظافة الكود: يجعل كود واجهة المستخدم (خاصة داخل TextFormField) أكثر نظافة وتركيزاً على العرض بدلاً من منطق التحقق المعقد.

🛠️ الوظائف الرئيسية بالتفصيل

1. دوال التحقق العامة

* validateRequired(String? value, String errorMessage): دالة أساسية تتأكد من أن الحقل ليس فارغاً. يمكن استخدامها لأي حقل إجباري.
* validateName(String? value, {String? fieldName}): مخصصة لحقول الأسماء، مع إمكانية تمرير اسم الحقل لعرض رسالة خطأ أكثر تحديداً (مثال: "الرجاء إدخال اسم الجهاز").
* validateDropdown<T>(T? value, {String? errorMessage}): دالة عامة (Generic) تتأكد من أن المستخدم قد اختار قيمة من قائمة منسدلة (Dropdown) وأنها ليست null.

2. دوال التحقق المتخصصة (باستخدام RegExp)

* validateSerialNumber(String? value): تتحقق من أن الرقم التسلسلي يتكون من 10 أحرف أو أرقام إنجليزية بالضبط.
* validateEmail(String? value): تستخدم تعبيراً نمطياً (Regular Expression) للتأكد من أن النص المدخل يتبع تنسيق البريد الإلكتروني القياسي.
* validatePhoneNumber(String? value): تتحقق من أن رقم الهاتف يتكون من 10 إلى 14 رقماً.
* validateOptionalUrl(String? value): تتحقق من صحة رابط URL. إذا كان الحقل فارغاً، تعتبره صالحاً (لأنه اختياري). إذا كان يحتوي على نص، تتأكد من أنه يتبع تنسيق URL الصحيح.

3. دوال مساعدة للفورم

* validateForm(GlobalKey<FormState> formKey, {VoidCallback? onValidationFailed}): دالة قوية لتشغيل عملية التحقق على جميع الحقول في فورم معين دفعة واحدة. يمكنها أيضاً استدعاء دالة رد نداء (callback) في حالة فشل التحقق، وهو أمر مفيد لإظهار رسالة خطأ عامة للمستخدم.

🚀 كيفية الاستخدام
بما أن جميع الدوال ثابتة، يمكنك استدعاؤها مباشرة داخل خاصية validator في أي TextFormField.

مثال على التحقق من اسم الجهاز:
TextFormField(
controller: \_deviceNameController,
decoration: InputDecoration(labelText: 'اسم الجهاز'),
validator: (value) => ValidationUtils.validateName(value, fieldName: 'اسم الجهاز'),
)

مثال على التحقق من الرقم التسلسلي:
TextFormField(
controller: \_serialNumberController,
decoration: InputDecoration(labelText: 'الرقم التسلسلي'),
validator: ValidationUtils.validateSerialNumber,
)

مثال على التحقق من الفورم بالكامل قبل الحفظ:
void \_saveForm() {
bool isFormValid = ValidationUtils.validateForm(
\_formKey,
onValidationFailed: () {
UIHelpers.showErrorSnackBar(context, 'يرجى تصحيح الأخطاء في النموذج');
},
);

if (isFormValid) {
// ... منطق الحفظ
}
}

----------------------------------------------------------------------------------------------------------------------------
ملف main.dart - نقطة انطلاق التطبيق

📝 نظرة عامة
يعتبر ملف main.dart هو نقطة الدخول (Entry Point) للتطبيق بأكمله. هو أول ملف يتم تنفيذه عند تشغيل التطبيق، ومسؤوليته الأساسية هي تهيئة الخدمات الضرورية (مثل Firebase) وإعداد البيئة العامة للتطبيق (مثل الثيم، اللغة، والاتجاه) ثم تشغيل الويدجت الجذري (MyApp).

🚀 الوظائف الرئيسية

1. دالة main()

* هذه هي الدالة الرئيسية التي يبدأ منها كل شيء. تم تحويلها إلى async لتتمكن من انتظار اكتمال العمليات غير المتزامنة قبل تشغيل واجهة المستخدم.
* WidgetsFlutterBinding.ensureInitialized(): هذا السطر ضروري للتأكد من أن "محرك فلاتر" قد تم تهيئته بالكامل قبل استدعاء أي خدمات تعتمد عليه، وهو أمر إلزامي عند استخدام Firebase.initializeApp() قبل runApp().
* await Firebase.initializeApp(...): يقوم بتهيئة خدمات Firebase في التطبيق باستخدام الإعدادات الموجودة في ملف firebase\_options.dart (الذي يتم إنشاؤه تلقائياً).
* SystemChrome.setPreferredOrientations(...): يقوم بتحديد اتجاهات الشاشة المسموح بها. في هذا التطبيق، تم تقييد الاتجاه ليكون عمودياً فقط (لأعلى ولأسفل)، مما يمنع دوران الشاشة إلى الوضع الأفقي ويوفر تجربة مستخدم أكثر اتساقاً.
* runApp(const MyApp()): بعد اكتمال جميع عمليات التهيئة، تقوم هذه الدالة بتشغيل التطبيق عن طريق بناء وعرض الويدجت الجذري MyApp.

2. كلاس MyApp

* الوظيفة: هو الويدجت الجذري للتطبيق. تم بناؤه كـ StatelessWidget لأنه لا يحتوي على أي حالة داخلية تتغير؛ وظيفته الأساسية هي بناء MaterialApp وتحديد الإعدادات العامة التي ستؤثر على جميع الشاشات.
* MaterialApp: هو الويدجت الأساسي الذي يوفر بنية التطبيق، بما في ذلك نظام التنقل (Navigation)، الثيم (Theme)، ودعم اللغات.

🎨 إعدادات الثيم والتصميم (Theming and Design)

* يتم تعريف وتخصيص المظهر العام للتطبيق بالكامل داخل MyApp لضمان الاتساق في جميع الشاشات.
* useMaterial3: true: تفعيل نظام التصميم الحديث من جوجل، Material 3.
* ColorScheme.fromSeed(...): طريقة ذكية لإنشاء نظام ألوان متكامل ومتناسق. بدلاً من تحديد كل لون على حدة، يتم توفير لون أساسي واحد (seedColor)، ويقوم فلاتر بإنشاء بقية الألوان (الأساسي، الثانوي، لون الخطأ، إلخ) بشكل متناغم.
* textTheme: GoogleFonts.cairoTextTheme(...): يتم تطبيق خط "Cairo" من مكتبة google\_fonts على جميع النصوص في التطبيق، مما يوفر مظهراً عربياً أنيقاً ومتسقاً.
* التخصيص الموحد (...Theme): تم تخصيص المظهر الافتراضي للعديد من الويدجتات الشائعة:

  * appBarTheme: لتوحيد تصميم جميع أشرطة العناوين.
  * cardTheme: لتوحيد شكل جميع البطاقات (حواف دائرية وظل).
  * inputDecorationTheme: لتوحيد مظهر جميع حقول الإدخال النصية.
  * filledButtonTheme و textButtonTheme: لتوحيد شكل الأزرار.

🌍 التعريب ودعم اللغة العربية (Localization and Arabic Support)

* تم إعداد التطبيق ليدعم اللغة العربية بشكل كامل:

  * locale: const Locale('ar', 'SA'): تحديد اللغة العربية (لهجة المملكة العربية السعودية) كلغة افتراضية للتطبيق.
  * localizationsDelegates: تحديد المندوبين المسؤولين عن ترجمة النصوص القياسية في واجهة المستخدم (مثل نصوص مربعات الحوار الافتراضية) إلى اللغة المحددة.
  * supportedLocales: تحديد قائمة اللغات التي يدعمها التطبيق (حالياً، العربية فقط).
* هذه الإعدادات تضمن أن أي نصوص افتراضية من فلاتر ستظهر باللغة العربية، وأن اتجاه الواجهة سيكون من اليمين إلى اليسار (RTL) تلقائياً.
----------------------------------------------------------------------------------------------------------------------------
ملف pubspec.yaml - خريطة مشروع فلاتر

📝 نظرة عامة
يعتبر ملف pubspec.yaml هو الملف التعريفي المركزي لأي مشروع فلاتر. إنه بمثابة "بطاقة الهوية" التي تحتوي على جميع المعلومات الأساسية عن التطبيق، بما في ذلك اسمه، إصداره، الاعتماديات (الحزم الخارجية)، والأصول (مثل الصور والخطوط). فهم هذا الملف ضروري لإدارة المشروع وتطويره بشكل صحيح.

🏛️ المعلومات الأساسية

* name: uquts1: الاسم التعريفي للمشروع. يجب أن يكون فريداً إذا تم نشره.
* description: "...": وصف موجز لوظيفة التطبيق.
* publish\_to: 'none': يمنع نشر هذه الحزمة عن طريق الخطأ على موقع pub.dev، وهو الإعداد الموصى به للتطبيقات الخاصة.
* version: 1.0.0+1: يمثل إصدار التطبيق. الرقم قبل + هو إصدار التطبيق الذي يراه المستخدم (e.g., v1.0.0)، والرقم بعد + هو رقم البناء (build number) الذي يستخدمه متجر التطبيقات لتتبع التحديثات.

⚙️ بيئة التشغيل (Environment)
يحدد هذا القسم إصدارات الأدوات المتوافقة مع المشروع لضمان عمله بشكل صحيح.

* sdk: '>=3.0.0 <4.0.0': يحدد أن التطبيق يتطلب إصدار Dart 3.0.0 أو أحدث، ولكنه غير متوافق مع إصدار 4.0.0.
* flutter: ">=3.16.0": يحدد أن التطبيق يتطلب إصدار Flutter 3.16.0 أو أحدث.

📦 الاعتماديات (Dependencies)
هذا هو القسم الأكثر أهمية، حيث يتم إدراج جميع الحزم الخارجية التي يعتمد عليها التطبيق. تم تقسيمها هنا حسب الوظيفة:

1. Firebase (للتكامل مع خدمات جوجل)

* firebase\_core: الحزمة الأساسية والضرورية لتهيئة وتشغيل أي خدمة من خدمات Firebase.
* cloud\_firestore: للتفاعل مع قاعدة بيانات Firestore، وهي قاعدة بيانات NoSQL سحابية لتخزين البيانات المنظمة (مثل معلومات المعامل والأجهزة).
* firebase\_storage: لتخزين الملفات الكبيرة مثل الصور ومقاطع الفيديو في سحابة Firebase.

2. قاعدة البيانات المحلية (Local Database)

* sqflite: لتوفير قاعدة بيانات SQLite محلية على جهاز المستخدم (مفيدة لتخزين البيانات مؤقتاً أو للعمل دون اتصال بالإنترنت).
* path & path\_provider: حزم مساعدة للتعامل مع مسارات الملفات والمجلدات على نظام التشغيل.

3. واجهة المستخدم والمكونات (UI & Components)

* google\_fonts: للوصول السهل إلى مكتبة خطوط جوجل واستخدامها في التطبيق.
* cupertino\_icons: لتوفير مجموعة الأيقونات القياسية لتصميم iOS.
* flutter\_svg: لعرض الصور والرسوميات بصيغة SVG.

4. مسح الباركود (QR/Barcode)

* mobile\_scanner: حزمة حديثة وفعالة لمسح الباركود ورموز QR باستخدام كاميرا الجهاز.
* barcode\_widget: لإنشاء وعرض ويدجت للباركود داخل التطبيق.

5. أدوات مساعدة (Utilities)

* image\_picker: لاختيار الصور من معرض الصور أو التقاطها مباشرة من الكاميرا.
* flutter\_image\_compress: لضغط الصور وتقليل حجمها قبل رفعها، مما يوفر مساحة تخزين وتكلفة بيانات.
* url\_launcher: لفتح الروابط الخارجية في المتصفح أو تطبيقات أخرى (مثل فتح موقع على الخريطة).
* uuid: لتوليد معرفات فريدة عالميًا (UUIDs)، وهي مفيدة لإنشاء IDs فريدة للمستندات في قاعدة البيانات.
* share\_plus: لتفعيل خاصية "مشاركة" المحتوى مع تطبيقات أخرى على الجهاز.
* shared\_preferences: لتخزين البيانات البسيطة والمستمرة على الجهاز (مثل إعدادات المستخدم أو حالة تسجيل الدخول).

👨‍💻 اعتماديات التطوير (Dev Dependencies)
هذه الحزم تُستخدم فقط أثناء عملية التطوير ولا يتم تضمينها في النسخة النهائية من التطبيق.

* flutter\_lints: توفر مجموعة من قواعد التحليل (linting) التي تساعد على كتابة كود نظيف، متسق، وخالٍ من الأخطاء الشائعة.

🖼️ إعدادات Flutter الخاصة
يحدد هذا القسم كيفية تعامل Flutter مع الأصول والخطوط المضمنة في المشروع.

* uses-material-design: true: يخبر Flutter بأن التطبيق يستخدم مكونات Material Design.
* assets: يتم هنا تسجيل جميع المجلدات والملفات التي تعتبر "أصولاً" للتطبيق، مثل الصور. يجب تسجيل أي صورة هنا قبل استخدامها في الكود.
* fonts: يتم هنا تعريف أي خطوط مخصصة تم تضمينها في المشروع. تم تعريف عائلة خط "Cairo" بأوزانها المختلفة (عادي، متوسط، غامق) لاستخدامها في التطبيق.
----------------------------------------------------------------------------------------------------------------------------
ملف خيارات Firebase (firebase\_options.dart)

📝 نظرة عامة
هذا الملف هو ملف يتم إنشاؤه تلقائياً بواسطة أدوات FlutterFire CLI (سطر أوامر فايربيس لفلاتر). لا يجب تعديل هذا الملف يدوياً.

وظيفته الأساسية هي توفير إعدادات التهيئة (Configuration Options) اللازمة لربط تطبيق فلاتر الخاص بك بمشروع Firebase على مختلف المنصات (Android, iOS, Web, macOS, Windows). كل منصة تتطلب مجموعة فريدة من المفاتيح والمعرفات للتواصل بشكل آمن مع خدمات Firebase.

🏛️ الهيكلة والوظيفة
يحتوي الكلاس DefaultFirebaseOptions على مكونين رئيسيين:

1. المتغير الثابت currentPlatform

* الوظيفة: هو getter ثابت وذكي يقوم تلقائياً بتحديد المنصة التي يعمل عليها التطبيق حالياً (Android, iOS, Web, etc.) ثم يُرجع كائن FirebaseOptions المناسب لتلك المنصة.
* الاستخدام: هذا هو المتغير الذي تستخدمه في ملف main.dart لتهيئة Firebase، كما في المثال التالي:

await Firebase.initializeApp(
options: DefaultFirebaseOptions.currentPlatform,
);

هذا السطر يضمن أن التطبيق سيستخدم مفاتيح الإعدادات الصحيحة تلقائياً بغض النظر عن المنصة التي يتم تشغيله عليها.

2. كائنات FirebaseOptions الثابتة لكل منصة

* يحتوي الكلاس على كائن FirebaseOptions ثابت لكل منصة مدعومة:

  * web
  * android
  * ios
  * macos
  * windows

كل كائن من هذه الكائنات يحتوي على مجموعة من المفاتيح والمعرفات الفريدة التي تم إنشاؤها عند تسجيل تطبيقك في مشروع Firebase. هذه المفاتيح هي التي تسمح لتطبيقك بالتصديق (Authenticate) والتواصل مع خدمات Firebase الخلفية.

* apiKey: مفتاح API للوصول إلى خدمات Firebase.
* appId: معرف فريد للتطبيق داخل مشروع Firebase.
* messagingSenderId: معرف مرسل الرسائل لخدمات مثل Firebase Cloud Messaging.
* projectId: معرف مشروع Firebase الخاص بك.
* storageBucket: رابط مساحة التخزين الافتراضية في Firebase Storage.
* authDomain: النطاق المستخدم لخدمة Firebase Authentication.
* iosBundleId / androidPackageName: المعرف الفريد للتطبيق على مستوى متجر التطبيقات.

⚠️ ملاحظات هامة

* لا تقم بتعديل هذا الملف يدوياً: إذا احتجت إلى تحديث إعدادات Firebase (على سبيل المثال، بعد إضافة منصة جديدة)، يجب عليك إعادة تشغيل الأمر flutterfire configure من الـ CLI، وسيقوم هو بتحديث هذا الملف تلقائياً.
* الأمان: على الرغم من أن هذا الملف يحتوي على مفاتيح API، إلا أنها تعتبر آمنة بشكل عام للكشف عنها في تطبيقات العميل (Client-side). يتم تأمين الوصول إلى بياناتك من خلال قواعد الأمان (Security Rules) التي تحددها في Firestore و Storage، وليس من خلال إخفاء هذه المفاتيح.
* UnsupportedError: إذا حاولت تشغيل التطبيق على منصة لم يتم تهيئتها (مثل Linux في الكود الحالي)، سيقوم currentPlatform بإطلاق خطأ UnsupportedError لإعلامك بأن الإعدادات غير موجودة.
----------------------------------------------------------------------------------------------------------------------------
نموذج بيانات الجهاز (DeviceModel)

📝 نظرة عامة
يعتبر ملف device\_model.dart هو المخطط الهندسي (Blueprint) الذي يمثل كائن "الجهاز" في التطبيق. يقوم هذا الكلاس بتعريف جميع الخصائص والبيانات التي يمكن أن يحتوي عليها أي جهاز، ويوفر دوال مساعدة لتحويل هذه البيانات من وإلى الصيغة التي تستخدمها قاعدة بيانات Firestore.

الهدف الأساسي من هذا النموذج هو هيكلة البيانات وتوحيدها، مما يضمن أن جميع أجزاء التطبيق (مثل شاشات العرض، النماذج، وخدمات قاعدة البيانات) تتعامل مع بيانات الجهاز بنفس الشكل المتسق.

🏛️ الخصائص (Properties)
يحتوي DeviceModel على مجموعة شاملة من الخصائص التي تصف الجهاز من جوانب مختلفة:

1. المعلومات الأساسية

* id: معرف فريد عالميًا (UUID) لكل جهاز.
* name: الاسم الوصفي للجهاز (مثال: "جهاز مكتبي HP").
* college: الكلية التي يتبع لها الجهاز.
* department: القسم داخل الكلية.
* labId: معرف المعمل الذي يوجد به الجهاز.

2. المواصفات الفنية

* model: موديل الجهاز (مثال: "Dell OptiPlex 7070").
* serialNumber: الرقم التسلسلي الفريد من الشركة المصنعة.
* processor: نوع المعالج (مثال: "Intel Core i7").
* storageType / storageSize: نوع وحجم التخزين الأساسي.
* hasExtraStorage: قيمة منطقية (bool) تشير إلى وجود تخزين إضافي.
* extraStorageType / extraStorageSize: تفاصيل التخزين الإضافي إن وجد.
* osVersion: إصدار نظام التشغيل.

3. بيانات إدارية

* universityBarcode / assetCode: الباركود ورمز الأصل المستخدمان في الجامعة.
* assetSource / assetCategory: مصدر وفئة الأصل.
* needsMaintenance: قيمة منطقية (bool) تشير إلى ما إذا كان الجهاز يحتاج إلى صيانة.
* imagePath: رابط (URL) لصورة الجهاز، تُستخدم بشكل خاص في حالة الصيانة.
* notes: أي ملاحظات إضافية حول الجهاز.
* createdAt / updatedAt: الطوابع الزمنية التي تسجل وقت إنشاء وتحديث سجل الجهاز.

🛠️ الوظائف الرئيسية (Key Methods)

1. toMap()

* الوظيفة: تقوم بتحويل كائن DeviceModel (الذي يستخدمه التطبيق) إلى خريطة (Map\<String, dynamic>).
* الأهمية: هذه الصيغة هي التي تفهمها قاعدة بيانات Firestore وتستخدمها لتخزين البيانات في مستند.
* ملاحظة: تقوم هذه الدالة بتحويل كائنات DateTime إلى Timestamp، وهو نوع البيانات المخصص للتاريخ والوقت في Firestore.

2. DeviceModel.fromMap(Map\<String, dynamic> map)

* الوظيفة: هي دالة مصنع (Factory Constructor) تقوم بالعملية العكسية؛ حيث تأخذ خريطة بيانات (Map) قادمة من Firestore وتحولها إلى كائن DeviceModel منظم يمكن للتطبيق التعامل معه.
* الأهمية: تضمن تحويل البيانات القادمة من قاعدة البيانات إلى كائنات Dart قوية ومحددة النوع.
* ميزات إضافية: تحتوي على منطق ذكي للتعامل مع أنواع البيانات المختلفة، مثل تحويل Timestamp إلى DateTime، والتعامل مع القيم المنطقية (bool) التي قد تكون مخزنة بصيغ مختلفة.

3. copyWith(...)

* الوظيفة: تسمح بإنشاء نسخة جديدة من كائن DeviceModel مع تعديل قيمة خاصية واحدة أو أكثر، دون تغيير الكائن الأصلي.
* الأهمية: هذه ممارسة جيدة في البرمجة الوظيفية وإدارة الحالة (State Management)، حيث تساعد على الحفاظ على ثبات البيانات (immutability) وتجنب الآثار الجانبية غير المتوقعة.

🚀 كيفية الاستخدام

مثال على إنشاء كائن جهاز جديد:
final newDevice = DeviceModel(
id: 'some\_unique\_id',
name: 'Dell Laptop',
college: 'كلية الحاسب الآلي',
model: 'Latitude 5420',
serialNumber: 'XYZ123ABC',
processor: 'Intel Core i5',
storageType: 'SSD',
storageSize: '256GB',
osVersion: 'Windows 11',
labId: 'lab\_id\_123',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
);

// يمكن الآن تحويله إلى Map لإرساله إلى Firestore
final deviceMap = newDevice.toMap();

----------------------------------------------------------------------------------------------------------------------------
نموذج بيانات المعمل (LabModel)

📝 نظرة عامة
يعتبر ملف lab\_model.dart هو المخطط الهندسي (Blueprint) الذي يمثل كائن "المعمل" في التطبيق. يقوم هذا الكلاس بتعريف جميع الخصائص والبيانات التي يمكن أن يحتوي عليها أي معمل، ويوفر دوال مساعدة لتحويل هذه البيانات من وإلى الصيغة التي تستخدمها قاعدة بيانات Firestore.

الهدف الأساسي من هذا النموذج هو هيكلة البيانات وتوحيدها، مما يضمن أن جميع أجزاء التطبيق (مثل شاشات العرض، النماذج، وخدمات قاعدة البيانات) تتعامل مع بيانات المعمل بنفس الشكل المتسق.

🏛️ الخصائص (Properties)
يحتوي LabModel على مجموعة شاملة من الخصائص التي تصف المعمل من جوانب مختلفة:

1. المعلومات الأساسية

* id: معرف فريد عالميًا (UUID) لكل معمل.
* labNumber: الرقم التعريفي للمعمل (مثال: "404", "A-101").
* college: الكلية التي يتبع لها المعمل.
* department: القسم داخل الكلية.
* floorNumber: رقم الدور الذي يقع فيه المعمل.
* type: نوع المعمل (مثال: "معمل حاسب آلي", "معمل فيزياء").

2. الحالة والبيانات الوصفية

* status: الحالة التشغيلية للمعمل، وهي من نوع LabStatus (Enum).
* notes: أي ملاحظات إدارية أو فنية حول المعمل.
* deviceIds: قائمة بمعرفات الأجهزة الموجودة داخل المعمل.
* imagePath: رابط (URL) لصورة المعمل، تُستخدم لعرض صورة توضيحية للمعمل أو لحالته.
* createdAt / updatedAt: الطوابع الزمنية التي تسجل وقت إنشاء وتحديث سجل المعمل.

3. معلومات الموقع

* locationUrl: رابط لموقع المعمل على خرائط جوجل.
* latitude / longitude: إحداثيات الموقع الجغرافي للمعمل (خط العرض وخط الطول).

🛠️ الوظائف الرئيسية (Key Methods)

1. toMap()

* الوظيفة: تقوم بتحويل كائن LabModel (الذي يستخدمه التطبيق) إلى خريطة (Map\<String, dynamic>).
* الأهمية: هذه الصيغة هي التي تفهمها قاعدة بيانات Firestore وتستخدمها لتخزين البيانات في مستند.
* ملاحظة: تقوم هذه الدالة بتحويل DateTime إلى Timestamp و LabStatus إلى String لتكون متوافقة مع Firestore.

2. LabModel.fromMap(Map\<String, dynamic> map)

* الوظيفة: هي دالة مصنع (Factory Constructor) تقوم بالعملية العكسية؛ حيث تأخذ خريطة بيانات (Map) قادمة من Firestore وتحولها إلى كائن LabModel منظم يمكن للتطبيق التعامل معه.
* الأهمية: تضمن تحويل البيانات القادمة من قاعدة البيانات إلى كائنات Dart قوية ومحددة النوع.
* ميزات إضافية: تحتوي على منطق ذكي للتعامل مع أنواع البيانات المختلفة، مثل تحويل Timestamp إلى DateTime، وتحويل String إلى LabStatus.

3. copyWith(...)

* الوظيفة: تسمح بإنشاء نسخة جديدة من كائن LabModel مع تعديل قيمة خاصية واحدة أو أكثر، دون تغيير الكائن الأصلي.
* الأهمية: هذه ممارسة جيدة في البرمجة الوظيفية وإدارة الحالة (State Management)، حيث تساعد على الحفاظ على ثبات البيانات (immutability) وتجنب الآثار الجانبية غير المتوقعة.

4. دوال Getter المساعدة

* getStatusColor(...): دالة getter تُرجع لوناً محدداً (Color) بناءً على حالة المعمل الحالية، مما يسهل عرض الحالة بشكل مرئي في واجهة المستخدم.
* getStatusText(): دالة getter تُرجع نصاً وصفياً باللغة العربية لحالة المعمل، مما يوحد النصوص في جميع أنحاء التطبيق.

🚦 تعداد الحالة (LabStatus Enum)
تم تعريف enum خاص باسم LabStatus لتحديد الحالات المحتملة للمعمل بشكل واضح ومقروء بدلاً من استخدام أرقام أو نصوص عشوائية. الحالات هي:

* openWithDevices: المعمل مفتوح ويحتوي على أجهزة (يُمثل باللون الأخضر).
* openNoDevices: المعمل مفتوح ولكن لا توجد به أجهزة أو به مشكلة (يُمثل باللون البرتقالي).
* closed: المعمل مغلق للصيانة أو لأي سبب آخر (يُمثل باللون الأحمر).

🚀 كيفية الاستخدام

مثال على إنشاء كائن معمل جديد:
final newLab = LabModel(
id: 'some\_unique\_id',
labNumber: 'C-205',
college: 'كلية الحاسب الآلي',
department: 'هندسة الحاسب الآلي',
floorNumber: 'الدور الثاني',
type: 'معمل شبكات',
status: LabStatus.openWithDevices,
notes: 'جميع الأجهزة تعمل بكفاءة.',
createdAt: DateTime.now(),
updatedAt: DateTime.now(),
);

// يمكن الآن تحويله إلى Map لإرساله إلى Firestore
final labMap = newLab.toMap();

----------------------------------------------------------------------------------------------------------------------------
ملف build.gradle (خاص بالتطبيق)

📝 نظرة عامة
يعتبر ملف build.gradle (الموجود داخل مجلد android/app) هو ملف الإعدادات المحوري لعملية بناء الجزء الأصلي (Native) من تطبيقك لنظام أندرويد. يتحكم هذا الملف في كل شيء بدءًا من تحديد إصدارات الـ SDK، مروراً بإدارة الاعتماديات الأصلية، وانتهاءً بكيفية تجميع وتوقيع النسخة النهائية من التطبيق (APK).

فهم هذا الملف ضروري لإدارة إعدادات أندرويد المتقدمة وحل المشاكل المتعلقة بعملية البناء.

🔌 الإضافات (Plugins)
يتم تعريف الإضافات الأساسية في بداية الملف، وكل منها له دور محدد:

* com.android.application: الإضافة الرئيسية التي تخبر Gradle بأن هذا المشروع هو تطبيق أندرويد قابل للتشغيل.
* com.google.gms.google-services: إضافة ضرورية لربط التطبيق بخدمات Google و Firebase. تقوم هذه الإضافة بقراءة ملف google-services.json وإعداد المفاتيح اللازمة تلقائياً.
* kotlin-android: تفعيل دعم لغة Kotlin في المشروع.
* dev.flutter.flutter-gradle-plugin: إضافة خاصة بفلاتر تقوم بدمج كود Dart ومكتباته مع عملية بناء Gradle الأصلية.

🤖 إعدادات أندرويد (Android Block)
هذا هو القسم الأكبر والأهم في الملف ويحتوي على جميع الإعدادات الخاصة بنظام أندرويد.

1. الإعدادات الأساسية

* namespace: معرف فريد للكود المصدري للتطبيق، وهو مطلوب في الإصدارات الحديثة من Gradle.
* compileSdk: إصدار Android SDK الذي يتم بناء التطبيق مقابله. يجب أن يكون عادةً أحدث إصدار متاح.
* defaultConfig: الإعدادات الافتراضية التي تنطبق على جميع أنواع البناء:

  * applicationId: المعرف الفريد للتطبيق في متجر Google Play.
  * minSdk: أقل إصدار من نظام أندرويد يمكن للتطبيق العمل عليه. تحديد رقم أقل يزيد من توافق التطبيق مع الأجهزة القديمة.
  * targetSdk: الإصدار المستهدف الذي تم اختبار التطبيق عليه بشكل كامل.
  * versionCode & versionName: يُستخدمان لإدارة إصدارات التطبيق في متجر Google Play.
  * multiDexEnabled = true: إعداد مهم يسمح للتطبيق بتجاوز حد 65 ألف دالة، وهو أمر ضروري في التطبيقات الكبيرة التي تستخدم مكتبات متعددة مثل Firebase.

2. أنواع البناء (Build Types)
   يسمح هذا القسم بتعريف إعدادات مختلفة لنسخ مختلفة من التطبيق، وأهمها:

* release (النسخة النهائية):

  * isMinifyEnabled = true: تفعيل تصغير حجم الكود (Minification) لإزالة الكود غير المستخدم وجعل التطبيق أصغر حجماً وأكثر صعوبة في الهندسة العكسية.
  * isShrinkResources = true: تفعيل تقليص حجم الموارد (مثل الصور والملفات) غير المستخدمة.
  * proguardFiles: تحديد ملفات قواعد ProGuard التي تخبر أداة التصغير بالكود الذي يجب الحفاظ عليه وعدم إزالته.
  * signingConfig: تحديد إعدادات توقيع النسخة النهائية من التطبيق، وهو أمر إلزامي لرفع التطبيق على متجر Google Play.
* debug (نسخة تصحيح الأخطاء):

  * applicationIdSuffix = ".debug": إضافة لاحقة لمعرف التطبيق، مما يسمح بتثبيت نسخة الـ Debug و الـ Release من نفس التطبيق على نفس الجهاز في نفس الوقت.

3. إعدادات أخرى

* packaging: تستخدم لحل مشاكل التضارب بين ملفات الترخيص التي قد تأتي من مكتبات مختلفة، عن طريق استثناء هذه الملفات من الحزمة النهائية.
* lint: إعدادات أداة تحليل الكود الثابت التي تساعد في اكتشاف الأخطاء المحتملة والمشاكل في الكود.

📦 الاعتماديات الأصلية (Native Dependencies)
يحتوي قسم dependencies في نهاية الملف على المكتبات الأصلية (Native) الخاصة بأندرويد فقط:

* kotlin-stdlib-jdk7: المكتبة القياسية للغة Kotlin.
* multidex: مكتبة الدعم اللازمة لتفعيل multiDexEnabled.
* play\:core: مكتبات Google Play Core التي قد تكون مطلوبة لبعض ميزات المتجر.
----------------------------------------------------------------------------------------------------------------------------
ملف google-services.json

📝 نظرة عامة
يعتبر ملف google-services.json هو ملف الإعدادات الأساسي الذي يربط تطبيق أندرويد الخاص بك بمشروعك على Firebase. يحتوي هذا الملف على جميع المعلومات اللازمة (مثل معرفات المشروع ومفاتيح API) التي تحتاجها خدمات Google و Firebase للتعرف على تطبيقك وتصديقه.

يتم تنزيل هذا الملف مباشرة من إعدادات مشروعك في Firebase Console ويجب وضعه داخل مجلد android/app في مشروع فلاتر.

🏛️ محتويات الملف
يحتوي الملف على بنية JSON منظمة تحتوي على المعلومات التالية:

* project\_info: يحتوي على معلومات عامة عن مشروع Firebase:

  * project\_number: رقم المشروع.
  * project\_id: المعرف الفريد لمشروعك (e.g., uquts-1c23c).
  * storage\_bucket: رابط مساحة التخزين الافتراضية في Firebase Storage.

* client: قائمة بالعملاء (التطبيقات) المسجلة في هذا المشروع. في حالتنا، هو تطبيق أندرويد واحد:

  * client\_info: معلومات خاصة بالعميل:

    * mobilesdk\_app\_id: المعرف الفريد لتطبيق أندرويد داخل Firebase.
    * android\_client\_info: يحتوي على package\_name الخاص بالتطبيق.
  * api\_key: قائمة بمفاتيح API المرتبطة بهذا التطبيق.
  * services: يحدد الخدمات الأخرى المرتبطة بالتطبيق.

⚠️ ملاحظة هامة جداً: الفرق بين نسخة التصحيح (Debug) والنسخة النهائية (Release)
هناك نقطة حيوية يجب الانتباه إليها بخصوص قيمة package\_name داخل هذا الملف لضمان عمل Firebase بشكل صحيح في كلتا الحالتين:

1. عند اختبار التطبيق (Debug Mode)

* المشكلة: في ملف build.gradle، يتم تلقائياً إضافة لاحقة .debug إلى معرف التطبيق (applicationId) عند بناء نسخة التصحيح (Debug). هذا يعني أن Firebase سيبحث عن تطبيق بالاسم com.example.uquts1.debug.
* الحل: عند اختبار التطبيق من Android Studio أو VS Code على محاكي أو جهاز، يجب أن تكون قيمة package\_name في ملف google-services.json كالتالي:

"package\_name": "com.example.uquts1.debug"

بهذه الطريقة، ستتمكن خدمات Firebase (مثل المصادقة وقاعدة البيانات) من التعرف على تطبيقك أثناء التطوير.

2. عند بناء النسخة النهائية (Release APK)

* المشكلة: عند بناء النسخة النهائية من التطبيق (APK أو App Bundle) التي سيتم رفعها للمتجر، لا يتم إضافة اللاحقة .debug. معرف التطبيق الفعلي سيكون com.example.uquts1.
* الحل: قبل بناء النسخة النهائية، يجب عليك تعديل ملف google-services.json وحذف كلمة .debug من package\_name لتصبح كالتالي:

"package\_name": "com.example.uquts1"

إذا لم تقم بهذه الخطوة، فإن خدمات Firebase لن تعمل في النسخة النهائية من تطبيقك التي سيستخدمها المستخدمون.

📌 باختصار:

* للتطوير والاختبار: com.example.uquts1.debug
* للنسخة النهائية (APK): com.example.uquts1
----------------------------------------------------------------------------------------------------------------------------